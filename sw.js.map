{"version":3,"file":"sw.js","sources":["../src/js/utils/storage.js","../src/js/sw/index.js"],"sourcesContent":["export const idbKeyval = (() => {\n  let dbInstance;\n\n  function getDB() {\n    if (dbInstance) return dbInstance;\n\n    dbInstance = new Promise((resolve, reject) => {\n      const openreq = indexedDB.open('svgo-keyval', 1);\n\n      openreq.onerror = () => {\n        reject(openreq.error);\n      };\n\n      openreq.onupgradeneeded = () => {\n        // First time setup: create an empty object store\n        openreq.result.createObjectStore('keyval');\n      };\n\n      openreq.onsuccess = () => {\n        resolve(openreq.result);\n      };\n    });\n\n    return dbInstance;\n  }\n\n  async function withStore(type, callback) {\n    const db = await getDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction('keyval', type);\n      transaction.oncomplete = () => resolve();\n      transaction.onerror = () => reject(transaction.error);\n      callback(transaction.objectStore('keyval'));\n    });\n  }\n\n  return {\n    async get(key) {\n      let request;\n      await withStore('readonly', (store) => {\n        request = store.get(key);\n      });\n      return request.result;\n    },\n    set(key, value) {\n      return withStore('readwrite', (store) => {\n        store.put(value, key);\n      });\n    },\n    delete(key) {\n      return withStore('readwrite', (store) => {\n        store.delete(key);\n      });\n    },\n  };\n})();\n","/* globals SVGOMG_VERSION:false */\n\nimport { idbKeyval as storage } from '../utils/storage.js';\n\nconst version = SVGOMG_VERSION;\nconst cachePrefix = 'svgomg-';\nconst staticCacheName = `${cachePrefix}static-${version}`;\nconst fontCacheName = `${cachePrefix}fonts`;\nconst expectedCaches = new Set([staticCacheName, fontCacheName]);\n\naddEventListener('install', (event) => {\n  event.waitUntil(\n    (async () => {\n      const activeVersionPromise = storage.get('active-version');\n      const cache = await caches.open(staticCacheName);\n\n      await cache.addAll([\n        './',\n        'imgs/icon.png',\n        'all.css',\n        'js/gzip-worker.js',\n        'js/page.js',\n        'js/prism-worker.js',\n        'js/svgo-worker.js',\n        'changelog.json',\n        'fonts/code-latin.woff2',\n      ]);\n\n      const activeVersion = await activeVersionPromise;\n\n      // If it's a major version change, don't skip waiting\n      if (\n        !activeVersion ||\n        activeVersion.split('.')[0] === version.split('.')[0]\n      ) {\n        self.skipWaiting();\n      }\n    })(),\n  );\n});\n\naddEventListener('activate', (event) => {\n  event.waitUntil(\n    (async () => {\n      // remove caches beginning \"svgomg-\" that aren't in expectedCaches\n      for (const cacheName of await caches.keys()) {\n        if (!cacheName.startsWith(cachePrefix)) continue;\n        // TODO: switch to Promise.all\n        // eslint-disable-next-line no-await-in-loop\n        if (!expectedCaches.has(cacheName)) await caches.delete(cacheName);\n      }\n\n      await storage.set('active-version', version);\n    })(),\n  );\n});\n\nasync function handleFontRequest(request) {\n  const match = await caches.match(request);\n  if (match) return match;\n\n  const [response, fontCache] = await Promise.all([\n    fetch(request),\n    caches.open(fontCacheName),\n  ]);\n\n  fontCache.put(request, response.clone());\n  return response;\n}\n\naddEventListener('fetch', (event) => {\n  const url = new URL(event.request.url);\n\n  if (url.pathname.endsWith('.woff2')) {\n    event.respondWith(handleFontRequest(event.request));\n    return;\n  }\n\n  event.respondWith(\n    caches\n      .match(event.request)\n      .then((response) => response || fetch(event.request)),\n  );\n});\n"],"names":["idbKeyval","dbInstance","async","withStore","type","callback","db","Promise","resolve","reject","openreq","indexedDB","open","onerror","error","onupgradeneeded","result","createObjectStore","onsuccess","transaction","oncomplete","objectStore","key","request","store","get","set","value","put","delete","version","cachePrefix","staticCacheName","fontCacheName","expectedCaches","Set","addEventListener","event","waitUntil","activeVersionPromise","storage","cache","caches","addAll","activeVersion","split","self","skipWaiting","cacheName","keys","startsWith","has","URL","url","pathname","endsWith","respondWith","match","response","fontCache","all","fetch","clone","handleFontRequest","then"],"mappings":"yBAAO,MAAMA,EAAY,MACvB,IAAIC,EAyBJC,eAAeC,EAAUC,EAAMC,GAC7B,MAAMC,QAvBFL,IAEJA,EAAa,IAAIM,SAAQ,CAACC,EAASC,KACjC,MAAMC,EAAUC,UAAUC,KAAK,cAAe,GAE9CF,EAAQG,QAAU,KAChBJ,EAAOC,EAAQI,QAGjBJ,EAAQK,gBAAkB,KAExBL,EAAQM,OAAOC,kBAAkB,WAGnCP,EAAQQ,UAAY,KAClBV,EAAQE,EAAQM,YAIbf,IAKP,OAAO,IAAIM,SAAQ,CAACC,EAASC,KAC3B,MAAMU,EAAcb,EAAGa,YAAY,SAAUf,GAC7Ce,EAAYC,WAAa,IAAMZ,IAC/BW,EAAYN,QAAU,IAAMJ,EAAOU,EAAYL,OAC/CT,EAASc,EAAYE,YAAY,cAIrC,MAAO,CACLnB,UAAUoB,GACR,IAAIC,EAIJ,aAHMpB,EAAU,YAAaqB,IAC3BD,EAAUC,EAAMC,IAAIH,MAEfC,EAAQP,QAEjBU,IAAG,CAACJ,EAAKK,IACAxB,EAAU,aAAcqB,IAC7BA,EAAMI,IAAID,EAAOL,MAGrBO,OAAOP,GACEnB,EAAU,aAAcqB,IAC7BA,EAAMK,OAAOP,QAnDI,GCInBQ,EAAU,SACVC,EAAc,UACdC,EAAkB,uBAClBC,EAAgB,eAChBC,EAAiB,IAAIC,IAAI,CAACH,EAAiBC,IAEjDG,iBAAiB,WAAYC,IAC3BA,EAAMC,UACJ,WACE,MAAMC,EAAuBC,EAAQf,IAAI,kBACnCgB,QAAcC,OAAO9B,KAAKoB,SAE1BS,EAAME,OAAO,CACjB,KACA,gBACA,UACA,oBACA,aACA,qBACA,oBACA,iBACA,2BAGF,MAAMC,QAAsBL,EAIzBK,GACDA,EAAcC,MAAM,KAAK,KAAOf,EAAQe,MAAM,KAAK,IAEnDC,KAAKC,eAvBT,OA6BJX,iBAAiB,YAAaC,IAC5BA,EAAMC,UACJ,WAEE,IAAK,MAAMU,WAAmBN,OAAOO,OAC9BD,EAAUE,WAAWnB,KAGrBG,EAAeiB,IAAIH,UAAkBN,OAAOb,OAAOmB,UAGpDR,EAAQd,IAAI,iBAAkBI,IATtC,OA2BJM,iBAAiB,SAAUC,IACb,IAAIe,IAAIf,EAAMd,QAAQ8B,KAE1BC,SAASC,SAAS,UACxBlB,EAAMmB,YAjBVtD,eAAiCqB,GAC/B,MAAMkC,QAAcf,OAAOe,MAAMlC,GACjC,GAAIkC,EAAO,OAAOA,EAElB,MAAOC,EAAUC,SAAmBpD,QAAQqD,IAAI,CAC9CC,MAAMtC,GACNmB,OAAO9B,KAAKqB,KAId,OADA0B,EAAU/B,IAAIL,EAASmC,EAASI,SACzBJ,EAOaK,CAAkB1B,EAAMd,UAI5Cc,EAAMmB,YACJd,OACGe,MAAMpB,EAAMd,SACZyC,MAAMN,GAAaA,GAAYG,MAAMxB,EAAMd"}