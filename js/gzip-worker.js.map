{"version":3,"file":"gzip-worker.js","sources":["../../node_modules/.pnpm/pako@2.0.4/node_modules/pako/dist/pako_deflate.js","../../src/js/gzip-worker/index.js"],"sourcesContent":["\n/*! pako 2.0.4 https://github.com/nodeca/pako @license (MIT AND Zlib) */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.pako = {}));\n}(this, (function (exports) { 'use strict';\n\n  // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n  //\n  // This software is provided 'as-is', without any express or implied\n  // warranty. In no event will the authors be held liable for any damages\n  // arising from the use of this software.\n  //\n  // Permission is granted to anyone to use this software for any purpose,\n  // including commercial applications, and to alter it and redistribute it\n  // freely, subject to the following restrictions:\n  //\n  // 1. The origin of this software must not be misrepresented; you must not\n  //   claim that you wrote the original software. If you use this software\n  //   in a product, an acknowledgment in the product documentation would be\n  //   appreciated but is not required.\n  // 2. Altered source versions must be plainly marked as such, and must not be\n  //   misrepresented as being the original software.\n  // 3. This notice may not be removed or altered from any source distribution.\n\n  /* eslint-disable space-unary-ops */\n\n  /* Public constants ==========================================================*/\n  /* ===========================================================================*/\n\n\n  //const Z_FILTERED          = 1;\n  //const Z_HUFFMAN_ONLY      = 2;\n  //const Z_RLE               = 3;\n  const Z_FIXED$1               = 4;\n  //const Z_DEFAULT_STRATEGY  = 0;\n\n  /* Possible values of the data_type field (though see inflate()) */\n  const Z_BINARY              = 0;\n  const Z_TEXT                = 1;\n  //const Z_ASCII             = 1; // = Z_TEXT\n  const Z_UNKNOWN$1             = 2;\n\n  /*============================================================================*/\n\n\n  function zero$1(buf) { let len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n  // From zutil.h\n\n  const STORED_BLOCK = 0;\n  const STATIC_TREES = 1;\n  const DYN_TREES    = 2;\n  /* The three kinds of block type */\n\n  const MIN_MATCH$1    = 3;\n  const MAX_MATCH$1    = 258;\n  /* The minimum and maximum match lengths */\n\n  // From deflate.h\n  /* ===========================================================================\n   * Internal compression state.\n   */\n\n  const LENGTH_CODES$1  = 29;\n  /* number of length codes, not counting the special END_BLOCK code */\n\n  const LITERALS$1      = 256;\n  /* number of literal bytes 0..255 */\n\n  const L_CODES$1       = LITERALS$1 + 1 + LENGTH_CODES$1;\n  /* number of Literal or Length codes, including the END_BLOCK code */\n\n  const D_CODES$1       = 30;\n  /* number of distance codes */\n\n  const BL_CODES$1      = 19;\n  /* number of codes used to transfer the bit lengths */\n\n  const HEAP_SIZE$1     = 2 * L_CODES$1 + 1;\n  /* maximum heap size */\n\n  const MAX_BITS$1      = 15;\n  /* All codes must not exceed MAX_BITS bits */\n\n  const Buf_size      = 16;\n  /* size of bit buffer in bi_buf */\n\n\n  /* ===========================================================================\n   * Constants\n   */\n\n  const MAX_BL_BITS = 7;\n  /* Bit length codes must not exceed MAX_BL_BITS bits */\n\n  const END_BLOCK   = 256;\n  /* end of block literal code */\n\n  const REP_3_6     = 16;\n  /* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\n  const REPZ_3_10   = 17;\n  /* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\n  const REPZ_11_138 = 18;\n  /* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\n  /* eslint-disable comma-spacing,array-bracket-spacing */\n  const extra_lbits =   /* extra bits for each length code */\n    new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]);\n\n  const extra_dbits =   /* extra bits for each distance code */\n    new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]);\n\n  const extra_blbits =  /* extra bits for each bit length code */\n    new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]);\n\n  const bl_order =\n    new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);\n  /* eslint-enable comma-spacing,array-bracket-spacing */\n\n  /* The lengths of the bit length codes are sent in order of decreasing\n   * probability, to avoid transmitting the lengths for unused bit length codes.\n   */\n\n  /* ===========================================================================\n   * Local data. These are initialized only once.\n   */\n\n  // We pre-fill arrays with 0 to avoid uninitialized gaps\n\n  const DIST_CODE_LEN = 512; /* see definition of array dist_code below */\n\n  // !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\n  const static_ltree  = new Array((L_CODES$1 + 2) * 2);\n  zero$1(static_ltree);\n  /* The static literal tree. Since the bit lengths are imposed, there is no\n   * need for the L_CODES extra codes used during heap construction. However\n   * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n   * below).\n   */\n\n  const static_dtree  = new Array(D_CODES$1 * 2);\n  zero$1(static_dtree);\n  /* The static distance tree. (Actually a trivial tree since all codes use\n   * 5 bits.)\n   */\n\n  const _dist_code    = new Array(DIST_CODE_LEN);\n  zero$1(_dist_code);\n  /* Distance codes. The first 256 values correspond to the distances\n   * 3 .. 258, the last 256 values correspond to the top 8 bits of\n   * the 15 bit distances.\n   */\n\n  const _length_code  = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);\n  zero$1(_length_code);\n  /* length code for each normalized match length (0 == MIN_MATCH) */\n\n  const base_length   = new Array(LENGTH_CODES$1);\n  zero$1(base_length);\n  /* First normalized length for each code (0 = MIN_MATCH) */\n\n  const base_dist     = new Array(D_CODES$1);\n  zero$1(base_dist);\n  /* First normalized distance for each code (0 = distance of 1) */\n\n\n  function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n\n    this.static_tree  = static_tree;  /* static tree or NULL */\n    this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */\n    this.extra_base   = extra_base;   /* base index for extra_bits */\n    this.elems        = elems;        /* max number of elements in the tree */\n    this.max_length   = max_length;   /* max bit length for the codes */\n\n    // show if `static_tree` has data or dummy - needed for monomorphic objects\n    this.has_stree    = static_tree && static_tree.length;\n  }\n\n\n  let static_l_desc;\n  let static_d_desc;\n  let static_bl_desc;\n\n\n  function TreeDesc(dyn_tree, stat_desc) {\n    this.dyn_tree = dyn_tree;     /* the dynamic tree */\n    this.max_code = 0;            /* largest code with non zero frequency */\n    this.stat_desc = stat_desc;   /* the corresponding static tree */\n  }\n\n\n\n  const d_code = (dist) => {\n\n    return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n  };\n\n\n  /* ===========================================================================\n   * Output a short LSB first on the stream.\n   * IN assertion: there is enough room in pendingBuf.\n   */\n  const put_short = (s, w) => {\n  //    put_byte(s, (uch)((w) & 0xff));\n  //    put_byte(s, (uch)((ush)(w) >> 8));\n    s.pending_buf[s.pending++] = (w) & 0xff;\n    s.pending_buf[s.pending++] = (w >>> 8) & 0xff;\n  };\n\n\n  /* ===========================================================================\n   * Send a value on a given number of bits.\n   * IN assertion: length <= 16 and value fits in length bits.\n   */\n  const send_bits = (s, value, length) => {\n\n    if (s.bi_valid > (Buf_size - length)) {\n      s.bi_buf |= (value << s.bi_valid) & 0xffff;\n      put_short(s, s.bi_buf);\n      s.bi_buf = value >> (Buf_size - s.bi_valid);\n      s.bi_valid += length - Buf_size;\n    } else {\n      s.bi_buf |= (value << s.bi_valid) & 0xffff;\n      s.bi_valid += length;\n    }\n  };\n\n\n  const send_code = (s, c, tree) => {\n\n    send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);\n  };\n\n\n  /* ===========================================================================\n   * Reverse the first len bits of a code, using straightforward code (a faster\n   * method would use a table)\n   * IN assertion: 1 <= len <= 15\n   */\n  const bi_reverse = (code, len) => {\n\n    let res = 0;\n    do {\n      res |= code & 1;\n      code >>>= 1;\n      res <<= 1;\n    } while (--len > 0);\n    return res >>> 1;\n  };\n\n\n  /* ===========================================================================\n   * Flush the bit buffer, keeping at most 7 bits in it.\n   */\n  const bi_flush = (s) => {\n\n    if (s.bi_valid === 16) {\n      put_short(s, s.bi_buf);\n      s.bi_buf = 0;\n      s.bi_valid = 0;\n\n    } else if (s.bi_valid >= 8) {\n      s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n      s.bi_buf >>= 8;\n      s.bi_valid -= 8;\n    }\n  };\n\n\n  /* ===========================================================================\n   * Compute the optimal bit lengths for a tree and update the total bit length\n   * for the current block.\n   * IN assertion: the fields freq and dad are set, heap[heap_max] and\n   *    above are the tree nodes sorted by increasing frequency.\n   * OUT assertions: the field len is set to the optimal bit length, the\n   *     array bl_count contains the frequencies for each bit length.\n   *     The length opt_len is updated; static_len is also updated if stree is\n   *     not null.\n   */\n  const gen_bitlen = (s, desc) =>\n  //    deflate_state *s;\n  //    tree_desc *desc;    /* the tree descriptor */\n  {\n    const tree            = desc.dyn_tree;\n    const max_code        = desc.max_code;\n    const stree           = desc.stat_desc.static_tree;\n    const has_stree       = desc.stat_desc.has_stree;\n    const extra           = desc.stat_desc.extra_bits;\n    const base            = desc.stat_desc.extra_base;\n    const max_length      = desc.stat_desc.max_length;\n    let h;              /* heap index */\n    let n, m;           /* iterate over the tree elements */\n    let bits;           /* bit length */\n    let xbits;          /* extra bits */\n    let f;              /* frequency */\n    let overflow = 0;   /* number of elements with bit length too large */\n\n    for (bits = 0; bits <= MAX_BITS$1; bits++) {\n      s.bl_count[bits] = 0;\n    }\n\n    /* In a first pass, compute the optimal bit lengths (which may\n     * overflow in the case of the bit length tree).\n     */\n    tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */\n\n    for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {\n      n = s.heap[h];\n      bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;\n      if (bits > max_length) {\n        bits = max_length;\n        overflow++;\n      }\n      tree[n * 2 + 1]/*.Len*/ = bits;\n      /* We overwrite tree[n].Dad which is no longer needed */\n\n      if (n > max_code) { continue; } /* not a leaf node */\n\n      s.bl_count[bits]++;\n      xbits = 0;\n      if (n >= base) {\n        xbits = extra[n - base];\n      }\n      f = tree[n * 2]/*.Freq*/;\n      s.opt_len += f * (bits + xbits);\n      if (has_stree) {\n        s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);\n      }\n    }\n    if (overflow === 0) { return; }\n\n    // Trace((stderr,\"\\nbit length overflow\\n\"));\n    /* This happens for example on obj2 and pic of the Calgary corpus */\n\n    /* Find the first bit length which could increase: */\n    do {\n      bits = max_length - 1;\n      while (s.bl_count[bits] === 0) { bits--; }\n      s.bl_count[bits]--;      /* move one leaf down the tree */\n      s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */\n      s.bl_count[max_length]--;\n      /* The brother of the overflow item also moves one step up,\n       * but this does not affect bl_count[max_length]\n       */\n      overflow -= 2;\n    } while (overflow > 0);\n\n    /* Now recompute all bit lengths, scanning in increasing frequency.\n     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n     * lengths instead of fixing only the wrong ones. This idea is taken\n     * from 'ar' written by Haruhiko Okumura.)\n     */\n    for (bits = max_length; bits !== 0; bits--) {\n      n = s.bl_count[bits];\n      while (n !== 0) {\n        m = s.heap[--h];\n        if (m > max_code) { continue; }\n        if (tree[m * 2 + 1]/*.Len*/ !== bits) {\n          // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n          s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;\n          tree[m * 2 + 1]/*.Len*/ = bits;\n        }\n        n--;\n      }\n    }\n  };\n\n\n  /* ===========================================================================\n   * Generate the codes for a given tree and bit counts (which need not be\n   * optimal).\n   * IN assertion: the array bl_count contains the bit length statistics for\n   * the given tree and the field len is set for all tree elements.\n   * OUT assertion: the field code is set for all tree elements of non\n   *     zero code length.\n   */\n  const gen_codes = (tree, max_code, bl_count) =>\n  //    ct_data *tree;             /* the tree to decorate */\n  //    int max_code;              /* largest code with non zero frequency */\n  //    ushf *bl_count;            /* number of codes at each bit length */\n  {\n    const next_code = new Array(MAX_BITS$1 + 1); /* next code value for each bit length */\n    let code = 0;              /* running code value */\n    let bits;                  /* bit index */\n    let n;                     /* code index */\n\n    /* The distribution counts are first used to generate the code values\n     * without bit reversal.\n     */\n    for (bits = 1; bits <= MAX_BITS$1; bits++) {\n      next_code[bits] = code = (code + bl_count[bits - 1]) << 1;\n    }\n    /* Check that the bit counts in bl_count are consistent. The last code\n     * must be all ones.\n     */\n    //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n    //        \"inconsistent bit counts\");\n    //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n    for (n = 0;  n <= max_code; n++) {\n      let len = tree[n * 2 + 1]/*.Len*/;\n      if (len === 0) { continue; }\n      /* Now reverse the bits */\n      tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);\n\n      //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n      //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n    }\n  };\n\n\n  /* ===========================================================================\n   * Initialize the various 'constant' tables.\n   */\n  const tr_static_init = () => {\n\n    let n;        /* iterates over tree elements */\n    let bits;     /* bit counter */\n    let length;   /* length value */\n    let code;     /* code value */\n    let dist;     /* distance index */\n    const bl_count = new Array(MAX_BITS$1 + 1);\n    /* number of codes at each bit length for an optimal tree */\n\n    // do check in _tr_init()\n    //if (static_init_done) return;\n\n    /* For some embedded targets, global variables are not initialized: */\n  /*#ifdef NO_INIT_GLOBAL_POINTERS\n    static_l_desc.static_tree = static_ltree;\n    static_l_desc.extra_bits = extra_lbits;\n    static_d_desc.static_tree = static_dtree;\n    static_d_desc.extra_bits = extra_dbits;\n    static_bl_desc.extra_bits = extra_blbits;\n  #endif*/\n\n    /* Initialize the mapping length (0..255) -> length code (0..28) */\n    length = 0;\n    for (code = 0; code < LENGTH_CODES$1 - 1; code++) {\n      base_length[code] = length;\n      for (n = 0; n < (1 << extra_lbits[code]); n++) {\n        _length_code[length++] = code;\n      }\n    }\n    //Assert (length == 256, \"tr_static_init: length != 256\");\n    /* Note that the length 255 (match length 258) can be represented\n     * in two different ways: code 284 + 5 bits or code 285, so we\n     * overwrite length_code[255] to use the best encoding:\n     */\n    _length_code[length - 1] = code;\n\n    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n    dist = 0;\n    for (code = 0; code < 16; code++) {\n      base_dist[code] = dist;\n      for (n = 0; n < (1 << extra_dbits[code]); n++) {\n        _dist_code[dist++] = code;\n      }\n    }\n    //Assert (dist == 256, \"tr_static_init: dist != 256\");\n    dist >>= 7; /* from now on, all distances are divided by 128 */\n    for (; code < D_CODES$1; code++) {\n      base_dist[code] = dist << 7;\n      for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {\n        _dist_code[256 + dist++] = code;\n      }\n    }\n    //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n    /* Construct the codes of the static literal tree */\n    for (bits = 0; bits <= MAX_BITS$1; bits++) {\n      bl_count[bits] = 0;\n    }\n\n    n = 0;\n    while (n <= 143) {\n      static_ltree[n * 2 + 1]/*.Len*/ = 8;\n      n++;\n      bl_count[8]++;\n    }\n    while (n <= 255) {\n      static_ltree[n * 2 + 1]/*.Len*/ = 9;\n      n++;\n      bl_count[9]++;\n    }\n    while (n <= 279) {\n      static_ltree[n * 2 + 1]/*.Len*/ = 7;\n      n++;\n      bl_count[7]++;\n    }\n    while (n <= 287) {\n      static_ltree[n * 2 + 1]/*.Len*/ = 8;\n      n++;\n      bl_count[8]++;\n    }\n    /* Codes 286 and 287 do not exist, but we must include them in the\n     * tree construction to get a canonical Huffman tree (longest code\n     * all ones)\n     */\n    gen_codes(static_ltree, L_CODES$1 + 1, bl_count);\n\n    /* The static distance tree is trivial: */\n    for (n = 0; n < D_CODES$1; n++) {\n      static_dtree[n * 2 + 1]/*.Len*/ = 5;\n      static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);\n    }\n\n    // Now data ready and we can init static trees\n    static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);\n    static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES$1, MAX_BITS$1);\n    static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES$1, MAX_BL_BITS);\n\n    //static_init_done = true;\n  };\n\n\n  /* ===========================================================================\n   * Initialize a new block.\n   */\n  const init_block = (s) => {\n\n    let n; /* iterates over tree elements */\n\n    /* Initialize the trees. */\n    for (n = 0; n < L_CODES$1;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }\n    for (n = 0; n < D_CODES$1;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }\n    for (n = 0; n < BL_CODES$1; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }\n\n    s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;\n    s.opt_len = s.static_len = 0;\n    s.last_lit = s.matches = 0;\n  };\n\n\n  /* ===========================================================================\n   * Flush the bit buffer and align the output on a byte boundary\n   */\n  const bi_windup = (s) =>\n  {\n    if (s.bi_valid > 8) {\n      put_short(s, s.bi_buf);\n    } else if (s.bi_valid > 0) {\n      //put_byte(s, (Byte)s->bi_buf);\n      s.pending_buf[s.pending++] = s.bi_buf;\n    }\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n  };\n\n  /* ===========================================================================\n   * Copy a stored block, storing first the length and its\n   * one's complement if requested.\n   */\n  const copy_block = (s, buf, len, header) =>\n  //DeflateState *s;\n  //charf    *buf;    /* the input data */\n  //unsigned len;     /* its length */\n  //int      header;  /* true if block header must be written */\n  {\n    bi_windup(s);        /* align on byte boundary */\n\n    if (header) {\n      put_short(s, len);\n      put_short(s, ~len);\n    }\n  //  while (len--) {\n  //    put_byte(s, *buf++);\n  //  }\n    s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);\n    s.pending += len;\n  };\n\n  /* ===========================================================================\n   * Compares to subtrees, using the tree depth as tie breaker when\n   * the subtrees have equal frequency. This minimizes the worst case length.\n   */\n  const smaller = (tree, n, m, depth) => {\n\n    const _n2 = n * 2;\n    const _m2 = m * 2;\n    return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||\n           (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));\n  };\n\n  /* ===========================================================================\n   * Restore the heap property by moving down the tree starting at node k,\n   * exchanging a node with the smallest of its two sons if necessary, stopping\n   * when the heap property is re-established (each father smaller than its\n   * two sons).\n   */\n  const pqdownheap = (s, tree, k) =>\n  //    deflate_state *s;\n  //    ct_data *tree;  /* the tree to restore */\n  //    int k;               /* node to move down */\n  {\n    const v = s.heap[k];\n    let j = k << 1;  /* left son of k */\n    while (j <= s.heap_len) {\n      /* Set j to the smallest of the two sons: */\n      if (j < s.heap_len &&\n        smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n        j++;\n      }\n      /* Exit if v is smaller than both sons */\n      if (smaller(tree, v, s.heap[j], s.depth)) { break; }\n\n      /* Exchange v with the smallest son */\n      s.heap[k] = s.heap[j];\n      k = j;\n\n      /* And continue down the tree, setting j to the left son of k */\n      j <<= 1;\n    }\n    s.heap[k] = v;\n  };\n\n\n  // inlined manually\n  // const SMALLEST = 1;\n\n  /* ===========================================================================\n   * Send the block data compressed using the given Huffman trees\n   */\n  const compress_block = (s, ltree, dtree) =>\n  //    deflate_state *s;\n  //    const ct_data *ltree; /* literal tree */\n  //    const ct_data *dtree; /* distance tree */\n  {\n    let dist;           /* distance of matched string */\n    let lc;             /* match length or unmatched char (if dist == 0) */\n    let lx = 0;         /* running index in l_buf */\n    let code;           /* the code to send */\n    let extra;          /* number of extra bits to send */\n\n    if (s.last_lit !== 0) {\n      do {\n        dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);\n        lc = s.pending_buf[s.l_buf + lx];\n        lx++;\n\n        if (dist === 0) {\n          send_code(s, lc, ltree); /* send a literal byte */\n          //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n        } else {\n          /* Here, lc is the match length - MIN_MATCH */\n          code = _length_code[lc];\n          send_code(s, code + LITERALS$1 + 1, ltree); /* send the length code */\n          extra = extra_lbits[code];\n          if (extra !== 0) {\n            lc -= base_length[code];\n            send_bits(s, lc, extra);       /* send the extra length bits */\n          }\n          dist--; /* dist is now the match distance - 1 */\n          code = d_code(dist);\n          //Assert (code < D_CODES, \"bad d_code\");\n\n          send_code(s, code, dtree);       /* send the distance code */\n          extra = extra_dbits[code];\n          if (extra !== 0) {\n            dist -= base_dist[code];\n            send_bits(s, dist, extra);   /* send the extra distance bits */\n          }\n        } /* literal or match pair ? */\n\n        /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n        //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n        //       \"pendingBuf overflow\");\n\n      } while (lx < s.last_lit);\n    }\n\n    send_code(s, END_BLOCK, ltree);\n  };\n\n\n  /* ===========================================================================\n   * Construct one Huffman tree and assigns the code bit strings and lengths.\n   * Update the total bit length for the current block.\n   * IN assertion: the field freq is set for all tree elements.\n   * OUT assertions: the fields len and code are set to the optimal bit length\n   *     and corresponding code. The length opt_len is updated; static_len is\n   *     also updated if stree is not null. The field max_code is set.\n   */\n  const build_tree = (s, desc) =>\n  //    deflate_state *s;\n  //    tree_desc *desc; /* the tree descriptor */\n  {\n    const tree     = desc.dyn_tree;\n    const stree    = desc.stat_desc.static_tree;\n    const has_stree = desc.stat_desc.has_stree;\n    const elems    = desc.stat_desc.elems;\n    let n, m;          /* iterate over heap elements */\n    let max_code = -1; /* largest code with non zero frequency */\n    let node;          /* new node being created */\n\n    /* Construct the initial heap, with least frequent element in\n     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n     * heap[0] is not used.\n     */\n    s.heap_len = 0;\n    s.heap_max = HEAP_SIZE$1;\n\n    for (n = 0; n < elems; n++) {\n      if (tree[n * 2]/*.Freq*/ !== 0) {\n        s.heap[++s.heap_len] = max_code = n;\n        s.depth[n] = 0;\n\n      } else {\n        tree[n * 2 + 1]/*.Len*/ = 0;\n      }\n    }\n\n    /* The pkzip format requires that at least one distance code exists,\n     * and that at least one bit should be sent even if there is only one\n     * possible code. So to avoid special checks later on we force at least\n     * two codes of non zero frequency.\n     */\n    while (s.heap_len < 2) {\n      node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);\n      tree[node * 2]/*.Freq*/ = 1;\n      s.depth[node] = 0;\n      s.opt_len--;\n\n      if (has_stree) {\n        s.static_len -= stree[node * 2 + 1]/*.Len*/;\n      }\n      /* node is 0 or 1 so it does not have extra bits */\n    }\n    desc.max_code = max_code;\n\n    /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n     * establish sub-heaps of increasing lengths:\n     */\n    for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }\n\n    /* Construct the Huffman tree by repeatedly combining the least two\n     * frequent nodes.\n     */\n    node = elems;              /* next internal node of the tree */\n    do {\n      //pqremove(s, tree, n);  /* n = node of least frequency */\n      /*** pqremove ***/\n      n = s.heap[1/*SMALLEST*/];\n      s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];\n      pqdownheap(s, tree, 1/*SMALLEST*/);\n      /***/\n\n      m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */\n\n      s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */\n      s.heap[--s.heap_max] = m;\n\n      /* Create a new node father of n and m */\n      tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;\n      s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n      tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;\n\n      /* and insert the new node in the heap */\n      s.heap[1/*SMALLEST*/] = node++;\n      pqdownheap(s, tree, 1/*SMALLEST*/);\n\n    } while (s.heap_len >= 2);\n\n    s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];\n\n    /* At this point, the fields freq and dad are set. We can now\n     * generate the bit lengths.\n     */\n    gen_bitlen(s, desc);\n\n    /* The field len is now set, we can generate the bit codes */\n    gen_codes(tree, max_code, s.bl_count);\n  };\n\n\n  /* ===========================================================================\n   * Scan a literal or distance tree to determine the frequencies of the codes\n   * in the bit length tree.\n   */\n  const scan_tree = (s, tree, max_code) =>\n  //    deflate_state *s;\n  //    ct_data *tree;   /* the tree to be scanned */\n  //    int max_code;    /* and its largest code of non zero frequency */\n  {\n    let n;                     /* iterates over all tree elements */\n    let prevlen = -1;          /* last emitted length */\n    let curlen;                /* length of current code */\n\n    let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n    let count = 0;             /* repeat count of the current code */\n    let max_count = 7;         /* max repeat count */\n    let min_count = 4;         /* min repeat count */\n\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n    }\n    tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */\n\n    for (n = 0; n <= max_code; n++) {\n      curlen = nextlen;\n      nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n      if (++count < max_count && curlen === nextlen) {\n        continue;\n\n      } else if (count < min_count) {\n        s.bl_tree[curlen * 2]/*.Freq*/ += count;\n\n      } else if (curlen !== 0) {\n\n        if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }\n        s.bl_tree[REP_3_6 * 2]/*.Freq*/++;\n\n      } else if (count <= 10) {\n        s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;\n\n      } else {\n        s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;\n      }\n\n      count = 0;\n      prevlen = curlen;\n\n      if (nextlen === 0) {\n        max_count = 138;\n        min_count = 3;\n\n      } else if (curlen === nextlen) {\n        max_count = 6;\n        min_count = 3;\n\n      } else {\n        max_count = 7;\n        min_count = 4;\n      }\n    }\n  };\n\n\n  /* ===========================================================================\n   * Send a literal or distance tree in compressed form, using the codes in\n   * bl_tree.\n   */\n  const send_tree = (s, tree, max_code) =>\n  //    deflate_state *s;\n  //    ct_data *tree; /* the tree to be scanned */\n  //    int max_code;       /* and its largest code of non zero frequency */\n  {\n    let n;                     /* iterates over all tree elements */\n    let prevlen = -1;          /* last emitted length */\n    let curlen;                /* length of current code */\n\n    let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n    let count = 0;             /* repeat count of the current code */\n    let max_count = 7;         /* max repeat count */\n    let min_count = 4;         /* min repeat count */\n\n    /* tree[max_code+1].Len = -1; */  /* guard already set */\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n    }\n\n    for (n = 0; n <= max_code; n++) {\n      curlen = nextlen;\n      nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n      if (++count < max_count && curlen === nextlen) {\n        continue;\n\n      } else if (count < min_count) {\n        do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);\n\n      } else if (curlen !== 0) {\n        if (curlen !== prevlen) {\n          send_code(s, curlen, s.bl_tree);\n          count--;\n        }\n        //Assert(count >= 3 && count <= 6, \" 3_6?\");\n        send_code(s, REP_3_6, s.bl_tree);\n        send_bits(s, count - 3, 2);\n\n      } else if (count <= 10) {\n        send_code(s, REPZ_3_10, s.bl_tree);\n        send_bits(s, count - 3, 3);\n\n      } else {\n        send_code(s, REPZ_11_138, s.bl_tree);\n        send_bits(s, count - 11, 7);\n      }\n\n      count = 0;\n      prevlen = curlen;\n      if (nextlen === 0) {\n        max_count = 138;\n        min_count = 3;\n\n      } else if (curlen === nextlen) {\n        max_count = 6;\n        min_count = 3;\n\n      } else {\n        max_count = 7;\n        min_count = 4;\n      }\n    }\n  };\n\n\n  /* ===========================================================================\n   * Construct the Huffman tree for the bit lengths and return the index in\n   * bl_order of the last bit length code to send.\n   */\n  const build_bl_tree = (s) => {\n\n    let max_blindex;  /* index of last bit length code of non zero freq */\n\n    /* Determine the bit length frequencies for literal and distance trees */\n    scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n    scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n\n    /* Build the bit length tree: */\n    build_tree(s, s.bl_desc);\n    /* opt_len now includes the length of the tree representations, except\n     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n     */\n\n    /* Determine the number of bit length codes to send. The pkzip format\n     * requires that at least 4 bit length codes be sent. (appnote.txt says\n     * 3 but the actual value used is 4.)\n     */\n    for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {\n      if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {\n        break;\n      }\n    }\n    /* Update opt_len to include the bit length tree and counts */\n    s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n    //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n    //        s->opt_len, s->static_len));\n\n    return max_blindex;\n  };\n\n\n  /* ===========================================================================\n   * Send the header for a block using dynamic Huffman trees: the counts, the\n   * lengths of the bit length codes, the literal tree and the distance tree.\n   * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n   */\n  const send_all_trees = (s, lcodes, dcodes, blcodes) =>\n  //    deflate_state *s;\n  //    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n  {\n    let rank;                    /* index in bl_order */\n\n    //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n    //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n    //        \"too many codes\");\n    //Tracev((stderr, \"\\nbl counts: \"));\n    send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */\n    send_bits(s, dcodes - 1,   5);\n    send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */\n    for (rank = 0; rank < blcodes; rank++) {\n      //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n      send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);\n    }\n    //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n    send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */\n    //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n    send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */\n    //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n  };\n\n\n  /* ===========================================================================\n   * Check if the data type is TEXT or BINARY, using the following algorithm:\n   * - TEXT if the two conditions below are satisfied:\n   *    a) There are no non-portable control characters belonging to the\n   *       \"black list\" (0..6, 14..25, 28..31).\n   *    b) There is at least one printable character belonging to the\n   *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n   * - BINARY otherwise.\n   * - The following partially-portable control characters form a\n   *   \"gray list\" that is ignored in this detection algorithm:\n   *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n   * IN assertion: the fields Freq of dyn_ltree are set.\n   */\n  const detect_data_type = (s) => {\n    /* black_mask is the bit mask of black-listed bytes\n     * set bits 0..6, 14..25, and 28..31\n     * 0xf3ffc07f = binary 11110011111111111100000001111111\n     */\n    let black_mask = 0xf3ffc07f;\n    let n;\n\n    /* Check for non-textual (\"black-listed\") bytes. */\n    for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n      if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {\n        return Z_BINARY;\n      }\n    }\n\n    /* Check for textual (\"white-listed\") bytes. */\n    if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||\n        s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {\n      return Z_TEXT;\n    }\n    for (n = 32; n < LITERALS$1; n++) {\n      if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {\n        return Z_TEXT;\n      }\n    }\n\n    /* There are no \"black-listed\" or \"white-listed\" bytes:\n     * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n     */\n    return Z_BINARY;\n  };\n\n\n  let static_init_done = false;\n\n  /* ===========================================================================\n   * Initialize the tree data structures for a new zlib stream.\n   */\n  const _tr_init$1 = (s) =>\n  {\n\n    if (!static_init_done) {\n      tr_static_init();\n      static_init_done = true;\n    }\n\n    s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);\n    s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);\n    s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n\n    /* Initialize the first block of the first file: */\n    init_block(s);\n  };\n\n\n  /* ===========================================================================\n   * Send a stored block\n   */\n  const _tr_stored_block$1 = (s, buf, stored_len, last) =>\n  //DeflateState *s;\n  //charf *buf;       /* input block */\n  //ulg stored_len;   /* length of input block */\n  //int last;         /* one if this is the last block for a file */\n  {\n    send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */\n    copy_block(s, buf, stored_len, true); /* with header */\n  };\n\n\n  /* ===========================================================================\n   * Send one empty static block to give enough lookahead for inflate.\n   * This takes 10 bits, of which 7 may remain in the bit buffer.\n   */\n  const _tr_align$1 = (s) => {\n    send_bits(s, STATIC_TREES << 1, 3);\n    send_code(s, END_BLOCK, static_ltree);\n    bi_flush(s);\n  };\n\n\n  /* ===========================================================================\n   * Determine the best encoding for the current block: dynamic trees, static\n   * trees or store, and output the encoded block to the zip file.\n   */\n  const _tr_flush_block$1 = (s, buf, stored_len, last) =>\n  //DeflateState *s;\n  //charf *buf;       /* input block, or NULL if too old */\n  //ulg stored_len;   /* length of input block */\n  //int last;         /* one if this is the last block for a file */\n  {\n    let opt_lenb, static_lenb;  /* opt_len and static_len in bytes */\n    let max_blindex = 0;        /* index of last bit length code of non zero freq */\n\n    /* Build the Huffman trees unless a stored block is forced */\n    if (s.level > 0) {\n\n      /* Check if the file is binary or text */\n      if (s.strm.data_type === Z_UNKNOWN$1) {\n        s.strm.data_type = detect_data_type(s);\n      }\n\n      /* Construct the literal and distance trees */\n      build_tree(s, s.l_desc);\n      // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n      //        s->static_len));\n\n      build_tree(s, s.d_desc);\n      // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n      //        s->static_len));\n      /* At this point, opt_len and static_len are the total bit lengths of\n       * the compressed block data, excluding the tree representations.\n       */\n\n      /* Build the bit length tree for the above two trees, and get the index\n       * in bl_order of the last bit length code to send.\n       */\n      max_blindex = build_bl_tree(s);\n\n      /* Determine the best encoding. Compute the block lengths in bytes. */\n      opt_lenb = (s.opt_len + 3 + 7) >>> 3;\n      static_lenb = (s.static_len + 3 + 7) >>> 3;\n\n      // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n      //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n      //        s->last_lit));\n\n      if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }\n\n    } else {\n      // Assert(buf != (char*)0, \"lost buf\");\n      opt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n    }\n\n    if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {\n      /* 4: two words for the lengths */\n\n      /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n       * Otherwise we can't have processed more than WSIZE input bytes since\n       * the last block flush, because compression would have been\n       * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n       * transform a block into a stored block.\n       */\n      _tr_stored_block$1(s, buf, stored_len, last);\n\n    } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {\n\n      send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n      compress_block(s, static_ltree, static_dtree);\n\n    } else {\n      send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n      send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n      compress_block(s, s.dyn_ltree, s.dyn_dtree);\n    }\n    // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n    /* The above check is made mod 2^32, for files larger than 512 MB\n     * and uLong implemented on 32 bits.\n     */\n    init_block(s);\n\n    if (last) {\n      bi_windup(s);\n    }\n    // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n    //       s->compressed_len-7*last));\n  };\n\n  /* ===========================================================================\n   * Save the match info and tally the frequency counts. Return true if\n   * the current block must be flushed.\n   */\n  const _tr_tally$1 = (s, dist, lc) =>\n  //    deflate_state *s;\n  //    unsigned dist;  /* distance of matched string */\n  //    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n  {\n    //let out_length, in_length, dcode;\n\n    s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;\n    s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n\n    s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n    s.last_lit++;\n\n    if (dist === 0) {\n      /* lc is the unmatched char */\n      s.dyn_ltree[lc * 2]/*.Freq*/++;\n    } else {\n      s.matches++;\n      /* Here, lc is the match length - MIN_MATCH */\n      dist--;             /* dist = match distance - 1 */\n      //Assert((ush)dist < (ush)MAX_DIST(s) &&\n      //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n      //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n      s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]/*.Freq*/++;\n      s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;\n    }\n\n  // (!) This block is disabled in zlib defaults,\n  // don't enable it for binary compatibility\n\n  //#ifdef TRUNCATE_BLOCK\n  //  /* Try to guess if it is profitable to stop the current block here */\n  //  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n  //    /* Compute an upper bound for the compressed length */\n  //    out_length = s.last_lit*8;\n  //    in_length = s.strstart - s.block_start;\n  //\n  //    for (dcode = 0; dcode < D_CODES; dcode++) {\n  //      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n  //    }\n  //    out_length >>>= 3;\n  //    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n  //    //       s->last_lit, in_length, out_length,\n  //    //       100L - out_length*100L/in_length));\n  //    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n  //      return true;\n  //    }\n  //  }\n  //#endif\n\n    return (s.last_lit === s.lit_bufsize - 1);\n    /* We avoid equality with lit_bufsize because of wraparound at 64K\n     * on 16 bit machines and because stored blocks are restricted to\n     * 64K-1 bytes.\n     */\n  };\n\n  var _tr_init_1  = _tr_init$1;\n  var _tr_stored_block_1 = _tr_stored_block$1;\n  var _tr_flush_block_1  = _tr_flush_block$1;\n  var _tr_tally_1 = _tr_tally$1;\n  var _tr_align_1 = _tr_align$1;\n\n  var trees = {\n  \t_tr_init: _tr_init_1,\n  \t_tr_stored_block: _tr_stored_block_1,\n  \t_tr_flush_block: _tr_flush_block_1,\n  \t_tr_tally: _tr_tally_1,\n  \t_tr_align: _tr_align_1\n  };\n\n  // Note: adler32 takes 12% for level 0 and 2% for level 6.\n  // It isn't worth it to make additional optimizations as in original.\n  // Small size is preferable.\n\n  // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n  //\n  // This software is provided 'as-is', without any express or implied\n  // warranty. In no event will the authors be held liable for any damages\n  // arising from the use of this software.\n  //\n  // Permission is granted to anyone to use this software for any purpose,\n  // including commercial applications, and to alter it and redistribute it\n  // freely, subject to the following restrictions:\n  //\n  // 1. The origin of this software must not be misrepresented; you must not\n  //   claim that you wrote the original software. If you use this software\n  //   in a product, an acknowledgment in the product documentation would be\n  //   appreciated but is not required.\n  // 2. Altered source versions must be plainly marked as such, and must not be\n  //   misrepresented as being the original software.\n  // 3. This notice may not be removed or altered from any source distribution.\n\n  const adler32 = (adler, buf, len, pos) => {\n    let s1 = (adler & 0xffff) |0,\n        s2 = ((adler >>> 16) & 0xffff) |0,\n        n = 0;\n\n    while (len !== 0) {\n      // Set limit ~ twice less than 5552, to keep\n      // s2 in 31-bits, because we force signed ints.\n      // in other case %= will fail.\n      n = len > 2000 ? 2000 : len;\n      len -= n;\n\n      do {\n        s1 = (s1 + buf[pos++]) |0;\n        s2 = (s2 + s1) |0;\n      } while (--n);\n\n      s1 %= 65521;\n      s2 %= 65521;\n    }\n\n    return (s1 | (s2 << 16)) |0;\n  };\n\n\n  var adler32_1 = adler32;\n\n  // Note: we can't get significant speed boost here.\n  // So write code to minimize size - no pregenerated tables\n  // and array tools dependencies.\n\n  // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n  //\n  // This software is provided 'as-is', without any express or implied\n  // warranty. In no event will the authors be held liable for any damages\n  // arising from the use of this software.\n  //\n  // Permission is granted to anyone to use this software for any purpose,\n  // including commercial applications, and to alter it and redistribute it\n  // freely, subject to the following restrictions:\n  //\n  // 1. The origin of this software must not be misrepresented; you must not\n  //   claim that you wrote the original software. If you use this software\n  //   in a product, an acknowledgment in the product documentation would be\n  //   appreciated but is not required.\n  // 2. Altered source versions must be plainly marked as such, and must not be\n  //   misrepresented as being the original software.\n  // 3. This notice may not be removed or altered from any source distribution.\n\n  // Use ordinary array, since untyped makes no boost here\n  const makeTable = () => {\n    let c, table = [];\n\n    for (var n = 0; n < 256; n++) {\n      c = n;\n      for (var k = 0; k < 8; k++) {\n        c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n      }\n      table[n] = c;\n    }\n\n    return table;\n  };\n\n  // Create table on load. Just 255 signed longs. Not a problem.\n  const crcTable = new Uint32Array(makeTable());\n\n\n  const crc32 = (crc, buf, len, pos) => {\n    const t = crcTable;\n    const end = pos + len;\n\n    crc ^= -1;\n\n    for (let i = pos; i < end; i++) {\n      crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];\n    }\n\n    return (crc ^ (-1)); // >>> 0;\n  };\n\n\n  var crc32_1 = crc32;\n\n  // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n  //\n  // This software is provided 'as-is', without any express or implied\n  // warranty. In no event will the authors be held liable for any damages\n  // arising from the use of this software.\n  //\n  // Permission is granted to anyone to use this software for any purpose,\n  // including commercial applications, and to alter it and redistribute it\n  // freely, subject to the following restrictions:\n  //\n  // 1. The origin of this software must not be misrepresented; you must not\n  //   claim that you wrote the original software. If you use this software\n  //   in a product, an acknowledgment in the product documentation would be\n  //   appreciated but is not required.\n  // 2. Altered source versions must be plainly marked as such, and must not be\n  //   misrepresented as being the original software.\n  // 3. This notice may not be removed or altered from any source distribution.\n\n  var messages = {\n    2:      'need dictionary',     /* Z_NEED_DICT       2  */\n    1:      'stream end',          /* Z_STREAM_END      1  */\n    0:      '',                    /* Z_OK              0  */\n    '-1':   'file error',          /* Z_ERRNO         (-1) */\n    '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */\n    '-3':   'data error',          /* Z_DATA_ERROR    (-3) */\n    '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */\n    '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */\n    '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */\n  };\n\n  // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n  //\n  // This software is provided 'as-is', without any express or implied\n  // warranty. In no event will the authors be held liable for any damages\n  // arising from the use of this software.\n  //\n  // Permission is granted to anyone to use this software for any purpose,\n  // including commercial applications, and to alter it and redistribute it\n  // freely, subject to the following restrictions:\n  //\n  // 1. The origin of this software must not be misrepresented; you must not\n  //   claim that you wrote the original software. If you use this software\n  //   in a product, an acknowledgment in the product documentation would be\n  //   appreciated but is not required.\n  // 2. Altered source versions must be plainly marked as such, and must not be\n  //   misrepresented as being the original software.\n  // 3. This notice may not be removed or altered from any source distribution.\n\n  var constants$1 = {\n\n    /* Allowed flush values; see deflate() and inflate() below for details */\n    Z_NO_FLUSH:         0,\n    Z_PARTIAL_FLUSH:    1,\n    Z_SYNC_FLUSH:       2,\n    Z_FULL_FLUSH:       3,\n    Z_FINISH:           4,\n    Z_BLOCK:            5,\n    Z_TREES:            6,\n\n    /* Return codes for the compression/decompression functions. Negative values\n    * are errors, positive values are used for special but normal events.\n    */\n    Z_OK:               0,\n    Z_STREAM_END:       1,\n    Z_NEED_DICT:        2,\n    Z_ERRNO:           -1,\n    Z_STREAM_ERROR:    -2,\n    Z_DATA_ERROR:      -3,\n    Z_MEM_ERROR:       -4,\n    Z_BUF_ERROR:       -5,\n    //Z_VERSION_ERROR: -6,\n\n    /* compression levels */\n    Z_NO_COMPRESSION:         0,\n    Z_BEST_SPEED:             1,\n    Z_BEST_COMPRESSION:       9,\n    Z_DEFAULT_COMPRESSION:   -1,\n\n\n    Z_FILTERED:               1,\n    Z_HUFFMAN_ONLY:           2,\n    Z_RLE:                    3,\n    Z_FIXED:                  4,\n    Z_DEFAULT_STRATEGY:       0,\n\n    /* Possible values of the data_type field (though see inflate()) */\n    Z_BINARY:                 0,\n    Z_TEXT:                   1,\n    //Z_ASCII:                1, // = Z_TEXT (deprecated)\n    Z_UNKNOWN:                2,\n\n    /* The deflate compression method */\n    Z_DEFLATED:               8\n    //Z_NULL:                 null // Use -1 or null inline, depending on var type\n  };\n\n  // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n  //\n  // This software is provided 'as-is', without any express or implied\n  // warranty. In no event will the authors be held liable for any damages\n  // arising from the use of this software.\n  //\n  // Permission is granted to anyone to use this software for any purpose,\n  // including commercial applications, and to alter it and redistribute it\n  // freely, subject to the following restrictions:\n  //\n  // 1. The origin of this software must not be misrepresented; you must not\n  //   claim that you wrote the original software. If you use this software\n  //   in a product, an acknowledgment in the product documentation would be\n  //   appreciated but is not required.\n  // 2. Altered source versions must be plainly marked as such, and must not be\n  //   misrepresented as being the original software.\n  // 3. This notice may not be removed or altered from any source distribution.\n\n  const { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;\n\n\n\n\n  /* Public constants ==========================================================*/\n  /* ===========================================================================*/\n\n  const {\n    Z_NO_FLUSH: Z_NO_FLUSH$1, Z_PARTIAL_FLUSH, Z_FULL_FLUSH: Z_FULL_FLUSH$1, Z_FINISH: Z_FINISH$1, Z_BLOCK,\n    Z_OK: Z_OK$1, Z_STREAM_END: Z_STREAM_END$1, Z_STREAM_ERROR, Z_DATA_ERROR, Z_BUF_ERROR,\n    Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,\n    Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED, Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,\n    Z_UNKNOWN,\n    Z_DEFLATED: Z_DEFLATED$1\n  } = constants$1;\n\n  /*============================================================================*/\n\n\n  const MAX_MEM_LEVEL = 9;\n  /* Maximum value for memLevel in deflateInit2 */\n  const MAX_WBITS = 15;\n  /* 32K LZ77 window */\n  const DEF_MEM_LEVEL = 8;\n\n\n  const LENGTH_CODES  = 29;\n  /* number of length codes, not counting the special END_BLOCK code */\n  const LITERALS      = 256;\n  /* number of literal bytes 0..255 */\n  const L_CODES       = LITERALS + 1 + LENGTH_CODES;\n  /* number of Literal or Length codes, including the END_BLOCK code */\n  const D_CODES       = 30;\n  /* number of distance codes */\n  const BL_CODES      = 19;\n  /* number of codes used to transfer the bit lengths */\n  const HEAP_SIZE     = 2 * L_CODES + 1;\n  /* maximum heap size */\n  const MAX_BITS  = 15;\n  /* All codes must not exceed MAX_BITS bits */\n\n  const MIN_MATCH = 3;\n  const MAX_MATCH = 258;\n  const MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\n\n  const PRESET_DICT = 0x20;\n\n  const INIT_STATE = 42;\n  const EXTRA_STATE = 69;\n  const NAME_STATE = 73;\n  const COMMENT_STATE = 91;\n  const HCRC_STATE = 103;\n  const BUSY_STATE = 113;\n  const FINISH_STATE = 666;\n\n  const BS_NEED_MORE      = 1; /* block not completed, need more input or more output */\n  const BS_BLOCK_DONE     = 2; /* block flush performed */\n  const BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */\n  const BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */\n\n  const OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n\n  const err = (strm, errorCode) => {\n    strm.msg = messages[errorCode];\n    return errorCode;\n  };\n\n  const rank = (f) => {\n    return ((f) << 1) - ((f) > 4 ? 9 : 0);\n  };\n\n  const zero = (buf) => {\n    let len = buf.length; while (--len >= 0) { buf[len] = 0; }\n  };\n\n\n  /* eslint-disable new-cap */\n  let HASH_ZLIB = (s, prev, data) => ((prev << s.hash_shift) ^ data) & s.hash_mask;\n  // This hash causes less collisions, https://github.com/nodeca/pako/issues/135\n  // But breaks binary compatibility\n  //let HASH_FAST = (s, prev, data) => ((prev << 8) + (prev >> 8) + (data << 4)) & s.hash_mask;\n  let HASH = HASH_ZLIB;\n\n  /* =========================================================================\n   * Flush as much pending output as possible. All deflate() output goes\n   * through this function so some applications may wish to modify it\n   * to avoid allocating a large strm->output buffer and copying into it.\n   * (See also read_buf()).\n   */\n  const flush_pending = (strm) => {\n    const s = strm.state;\n\n    //_tr_flush_bits(s);\n    let len = s.pending;\n    if (len > strm.avail_out) {\n      len = strm.avail_out;\n    }\n    if (len === 0) { return; }\n\n    strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);\n    strm.next_out += len;\n    s.pending_out += len;\n    strm.total_out += len;\n    strm.avail_out -= len;\n    s.pending -= len;\n    if (s.pending === 0) {\n      s.pending_out = 0;\n    }\n  };\n\n\n  const flush_block_only = (s, last) => {\n    _tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);\n    s.block_start = s.strstart;\n    flush_pending(s.strm);\n  };\n\n\n  const put_byte = (s, b) => {\n    s.pending_buf[s.pending++] = b;\n  };\n\n\n  /* =========================================================================\n   * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n   * IN assertion: the stream state is correct and there is enough room in\n   * pending_buf.\n   */\n  const putShortMSB = (s, b) => {\n\n    //  put_byte(s, (Byte)(b >> 8));\n  //  put_byte(s, (Byte)(b & 0xff));\n    s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\n    s.pending_buf[s.pending++] = b & 0xff;\n  };\n\n\n  /* ===========================================================================\n   * Read a new buffer from the current input stream, update the adler32\n   * and total number of bytes read.  All deflate() input goes through\n   * this function so some applications may wish to modify it to avoid\n   * allocating a large strm->input buffer and copying from it.\n   * (See also flush_pending()).\n   */\n  const read_buf = (strm, buf, start, size) => {\n\n    let len = strm.avail_in;\n\n    if (len > size) { len = size; }\n    if (len === 0) { return 0; }\n\n    strm.avail_in -= len;\n\n    // zmemcpy(buf, strm->next_in, len);\n    buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);\n    if (strm.state.wrap === 1) {\n      strm.adler = adler32_1(strm.adler, buf, len, start);\n    }\n\n    else if (strm.state.wrap === 2) {\n      strm.adler = crc32_1(strm.adler, buf, len, start);\n    }\n\n    strm.next_in += len;\n    strm.total_in += len;\n\n    return len;\n  };\n\n\n  /* ===========================================================================\n   * Set match_start to the longest match starting at the given string and\n   * return its length. Matches shorter or equal to prev_length are discarded,\n   * in which case the result is equal to prev_length and match_start is\n   * garbage.\n   * IN assertions: cur_match is the head of the hash chain for the current\n   *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n   * OUT assertion: the match length is not greater than s->lookahead.\n   */\n  const longest_match = (s, cur_match) => {\n\n    let chain_length = s.max_chain_length;      /* max hash chain length */\n    let scan = s.strstart; /* current string */\n    let match;                       /* matched string */\n    let len;                           /* length of current match */\n    let best_len = s.prev_length;              /* best match length so far */\n    let nice_match = s.nice_match;             /* stop if match long enough */\n    const limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?\n        s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;\n\n    const _win = s.window; // shortcut\n\n    const wmask = s.w_mask;\n    const prev  = s.prev;\n\n    /* Stop when cur_match becomes <= limit. To simplify the code,\n     * we prevent matches with the string of window index 0.\n     */\n\n    const strend = s.strstart + MAX_MATCH;\n    let scan_end1  = _win[scan + best_len - 1];\n    let scan_end   = _win[scan + best_len];\n\n    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n     * It is easy to get rid of this optimization if necessary.\n     */\n    // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n    /* Do not waste too much time if we already have a good match: */\n    if (s.prev_length >= s.good_match) {\n      chain_length >>= 2;\n    }\n    /* Do not look for matches beyond the end of the input. This is necessary\n     * to make deflate deterministic.\n     */\n    if (nice_match > s.lookahead) { nice_match = s.lookahead; }\n\n    // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n    do {\n      // Assert(cur_match < s->strstart, \"no future\");\n      match = cur_match;\n\n      /* Skip to next match if the match length cannot increase\n       * or if the match length is less than 2.  Note that the checks below\n       * for insufficient lookahead only occur occasionally for performance\n       * reasons.  Therefore uninitialized memory will be accessed, and\n       * conditional jumps will be made that depend on those values.\n       * However the length of the match is limited to the lookahead, so\n       * the output of deflate is not affected by the uninitialized values.\n       */\n\n      if (_win[match + best_len]     !== scan_end  ||\n          _win[match + best_len - 1] !== scan_end1 ||\n          _win[match]                !== _win[scan] ||\n          _win[++match]              !== _win[scan + 1]) {\n        continue;\n      }\n\n      /* The check at best_len-1 can be removed because it will be made\n       * again later. (This heuristic is not always a win.)\n       * It is not necessary to compare scan[2] and match[2] since they\n       * are always equal when the other bytes match, given that\n       * the hash keys are equal and that HASH_BITS >= 8.\n       */\n      scan += 2;\n      match++;\n      // Assert(*scan == *match, \"match[2]?\");\n\n      /* We check for insufficient lookahead only every 8th comparison;\n       * the 256th check will be made at strstart+258.\n       */\n      do {\n        /*jshint noempty:false*/\n      } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n               _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n               _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n               _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n               scan < strend);\n\n      // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n      len = MAX_MATCH - (strend - scan);\n      scan = strend - MAX_MATCH;\n\n      if (len > best_len) {\n        s.match_start = cur_match;\n        best_len = len;\n        if (len >= nice_match) {\n          break;\n        }\n        scan_end1  = _win[scan + best_len - 1];\n        scan_end   = _win[scan + best_len];\n      }\n    } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\n    if (best_len <= s.lookahead) {\n      return best_len;\n    }\n    return s.lookahead;\n  };\n\n\n  /* ===========================================================================\n   * Fill the window when the lookahead becomes insufficient.\n   * Updates strstart and lookahead.\n   *\n   * IN assertion: lookahead < MIN_LOOKAHEAD\n   * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n   *    At least one byte has been read, or avail_in == 0; reads are\n   *    performed for at least two bytes (required for the zip translate_eol\n   *    option -- not supported here).\n   */\n  const fill_window = (s) => {\n\n    const _w_size = s.w_size;\n    let p, n, m, more, str;\n\n    //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n    do {\n      more = s.window_size - s.lookahead - s.strstart;\n\n      // JS ints have 32 bit, block below not needed\n      /* Deal with !@#$% 64K limit: */\n      //if (sizeof(int) <= 2) {\n      //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n      //        more = wsize;\n      //\n      //  } else if (more == (unsigned)(-1)) {\n      //        /* Very unlikely, but possible on 16 bit machine if\n      //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n      //         */\n      //        more--;\n      //    }\n      //}\n\n\n      /* If the window is almost full and there is insufficient lookahead,\n       * move the upper half to the lower one to make room in the upper half.\n       */\n      if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n\n        s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);\n        s.match_start -= _w_size;\n        s.strstart -= _w_size;\n        /* we now have strstart >= MAX_DIST */\n        s.block_start -= _w_size;\n\n        /* Slide the hash table (could be avoided with 32 bit values\n         at the expense of memory usage). We slide even when level == 0\n         to keep the hash table consistent if we switch back to level > 0\n         later. (Using level 0 permanently is not an optimal usage of\n         zlib, so we don't care about this pathological case.)\n         */\n\n        n = s.hash_size;\n        p = n;\n\n        do {\n          m = s.head[--p];\n          s.head[p] = (m >= _w_size ? m - _w_size : 0);\n        } while (--n);\n\n        n = _w_size;\n        p = n;\n\n        do {\n          m = s.prev[--p];\n          s.prev[p] = (m >= _w_size ? m - _w_size : 0);\n          /* If n is not on any hash chain, prev[n] is garbage but\n           * its value will never be used.\n           */\n        } while (--n);\n\n        more += _w_size;\n      }\n      if (s.strm.avail_in === 0) {\n        break;\n      }\n\n      /* If there was no sliding:\n       *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n       *    more == window_size - lookahead - strstart\n       * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n       * => more >= window_size - 2*WSIZE + 2\n       * In the BIG_MEM or MMAP case (not yet supported),\n       *   window_size == input_size + MIN_LOOKAHEAD  &&\n       *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n       * Otherwise, window_size == 2*WSIZE so more >= 2.\n       * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n       */\n      //Assert(more >= 2, \"more < 2\");\n      n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n      s.lookahead += n;\n\n      /* Initialize the hash value now that we have some input: */\n      if (s.lookahead + s.insert >= MIN_MATCH) {\n        str = s.strstart - s.insert;\n        s.ins_h = s.window[str];\n\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n        s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);\n  //#if MIN_MATCH != 3\n  //        Call update_hash() MIN_MATCH-3 more times\n  //#endif\n        while (s.insert) {\n          /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n          s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);\n\n          s.prev[str & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = str;\n          str++;\n          s.insert--;\n          if (s.lookahead + s.insert < MIN_MATCH) {\n            break;\n          }\n        }\n      }\n      /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n       * but this is not important since only literal bytes will be emitted.\n       */\n\n    } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n\n    /* If the WIN_INIT bytes after the end of the current data have never been\n     * written, then zero those bytes in order to avoid memory check reports of\n     * the use of uninitialized (or uninitialised as Julian writes) bytes by\n     * the longest match routines.  Update the high water mark for the next\n     * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n     * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n     */\n  //  if (s.high_water < s.window_size) {\n  //    const curr = s.strstart + s.lookahead;\n  //    let init = 0;\n  //\n  //    if (s.high_water < curr) {\n  //      /* Previous high water mark below current data -- zero WIN_INIT\n  //       * bytes or up to end of window, whichever is less.\n  //       */\n  //      init = s.window_size - curr;\n  //      if (init > WIN_INIT)\n  //        init = WIN_INIT;\n  //      zmemzero(s->window + curr, (unsigned)init);\n  //      s->high_water = curr + init;\n  //    }\n  //    else if (s->high_water < (ulg)curr + WIN_INIT) {\n  //      /* High water mark at or above current data, but below current data\n  //       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n  //       * to end of window, whichever is less.\n  //       */\n  //      init = (ulg)curr + WIN_INIT - s->high_water;\n  //      if (init > s->window_size - s->high_water)\n  //        init = s->window_size - s->high_water;\n  //      zmemzero(s->window + s->high_water, (unsigned)init);\n  //      s->high_water += init;\n  //    }\n  //  }\n  //\n  //  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n  //    \"not enough room for search\");\n  };\n\n  /* ===========================================================================\n   * Copy without compression as much as possible from the input stream, return\n   * the current block state.\n   * This function does not insert new strings in the dictionary since\n   * uncompressible data is probably not useful. This function is used\n   * only for the level=0 compression option.\n   * NOTE: this function should be optimized to avoid extra copying from\n   * window to pending_buf.\n   */\n  const deflate_stored = (s, flush) => {\n\n    /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n     * to pending_buf_size, and each stored block has a 5 byte header:\n     */\n    let max_block_size = 0xffff;\n\n    if (max_block_size > s.pending_buf_size - 5) {\n      max_block_size = s.pending_buf_size - 5;\n    }\n\n    /* Copy as much as possible from input to output: */\n    for (;;) {\n      /* Fill the window as much as possible: */\n      if (s.lookahead <= 1) {\n\n        //Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n        //  s->block_start >= (long)s->w_size, \"slide too late\");\n  //      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n  //        s.block_start >= s.w_size)) {\n  //        throw  new Error(\"slide too late\");\n  //      }\n\n        fill_window(s);\n        if (s.lookahead === 0 && flush === Z_NO_FLUSH$1) {\n          return BS_NEED_MORE;\n        }\n\n        if (s.lookahead === 0) {\n          break;\n        }\n        /* flush the current block */\n      }\n      //Assert(s->block_start >= 0L, \"block gone\");\n  //    if (s.block_start < 0) throw new Error(\"block gone\");\n\n      s.strstart += s.lookahead;\n      s.lookahead = 0;\n\n      /* Emit a stored block if pending_buf will be full: */\n      const max_start = s.block_start + max_block_size;\n\n      if (s.strstart === 0 || s.strstart >= max_start) {\n        /* strstart == 0 is possible when wraparound on 16-bit machine */\n        s.lookahead = s.strstart - max_start;\n        s.strstart = max_start;\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n\n\n      }\n      /* Flush if we may have to slide, otherwise block_start may become\n       * negative and the data will be gone:\n       */\n      if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n    }\n\n    s.insert = 0;\n\n    if (flush === Z_FINISH$1) {\n      /*** FLUSH_BLOCK(s, 1); ***/\n      flush_block_only(s, true);\n      if (s.strm.avail_out === 0) {\n        return BS_FINISH_STARTED;\n      }\n      /***/\n      return BS_FINISH_DONE;\n    }\n\n    if (s.strstart > s.block_start) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n\n    return BS_NEED_MORE;\n  };\n\n  /* ===========================================================================\n   * Compress as much as possible from the input stream, return the current\n   * block state.\n   * This function does not perform lazy evaluation of matches and inserts\n   * new strings in the dictionary only for unmatched strings or for short\n   * matches. It is used only for the fast compression options.\n   */\n  const deflate_fast = (s, flush) => {\n\n    let hash_head;        /* head of the hash chain */\n    let bflush;           /* set if current block must be flushed */\n\n    for (;;) {\n      /* Make sure that we always have enough lookahead, except\n       * at the end of the input file. We need MAX_MATCH bytes\n       * for the next match, plus MIN_MATCH bytes to insert the\n       * string following the next match.\n       */\n      if (s.lookahead < MIN_LOOKAHEAD) {\n        fill_window(s);\n        if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$1) {\n          return BS_NEED_MORE;\n        }\n        if (s.lookahead === 0) {\n          break; /* flush the current block */\n        }\n      }\n\n      /* Insert the string window[strstart .. strstart+2] in the\n       * dictionary, and set hash_head to the head of the hash chain:\n       */\n      hash_head = 0/*NIL*/;\n      if (s.lookahead >= MIN_MATCH) {\n        /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n        s.head[s.ins_h] = s.strstart;\n        /***/\n      }\n\n      /* Find the longest match, discarding those <= prev_length.\n       * At this point we have always match_length < MIN_MATCH\n       */\n      if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {\n        /* To simplify the code, we prevent matches with the string\n         * of window index 0 (in particular we have to avoid a match\n         * of the string with itself at the start of the input file).\n         */\n        s.match_length = longest_match(s, hash_head);\n        /* longest_match() sets match_start */\n      }\n      if (s.match_length >= MIN_MATCH) {\n        // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n        /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                       s.match_length - MIN_MATCH, bflush); ***/\n        bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n\n        s.lookahead -= s.match_length;\n\n        /* Insert new strings in the hash table only if the match length\n         * is not too large. This saves time but degrades compression.\n         */\n        if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {\n          s.match_length--; /* string at strstart already in table */\n          do {\n            s.strstart++;\n            /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n            s.head[s.ins_h] = s.strstart;\n            /***/\n            /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n             * always MIN_MATCH bytes ahead.\n             */\n          } while (--s.match_length !== 0);\n          s.strstart++;\n        } else\n        {\n          s.strstart += s.match_length;\n          s.match_length = 0;\n          s.ins_h = s.window[s.strstart];\n          /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);\n\n  //#if MIN_MATCH != 3\n  //                Call UPDATE_HASH() MIN_MATCH-3 more times\n  //#endif\n          /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n           * matter since it will be recomputed at next deflate call.\n           */\n        }\n      } else {\n        /* No match, output a literal byte */\n        //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n        /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n        bflush = _tr_tally(s, 0, s.window[s.strstart]);\n\n        s.lookahead--;\n        s.strstart++;\n      }\n      if (bflush) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n    }\n    s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);\n    if (flush === Z_FINISH$1) {\n      /*** FLUSH_BLOCK(s, 1); ***/\n      flush_block_only(s, true);\n      if (s.strm.avail_out === 0) {\n        return BS_FINISH_STARTED;\n      }\n      /***/\n      return BS_FINISH_DONE;\n    }\n    if (s.last_lit) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n    return BS_BLOCK_DONE;\n  };\n\n  /* ===========================================================================\n   * Same as above, but achieves better compression. We use a lazy\n   * evaluation for matches: a match is finally adopted only if there is\n   * no better match at the next window position.\n   */\n  const deflate_slow = (s, flush) => {\n\n    let hash_head;          /* head of hash chain */\n    let bflush;              /* set if current block must be flushed */\n\n    let max_insert;\n\n    /* Process the input block. */\n    for (;;) {\n      /* Make sure that we always have enough lookahead, except\n       * at the end of the input file. We need MAX_MATCH bytes\n       * for the next match, plus MIN_MATCH bytes to insert the\n       * string following the next match.\n       */\n      if (s.lookahead < MIN_LOOKAHEAD) {\n        fill_window(s);\n        if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$1) {\n          return BS_NEED_MORE;\n        }\n        if (s.lookahead === 0) { break; } /* flush the current block */\n      }\n\n      /* Insert the string window[strstart .. strstart+2] in the\n       * dictionary, and set hash_head to the head of the hash chain:\n       */\n      hash_head = 0/*NIL*/;\n      if (s.lookahead >= MIN_MATCH) {\n        /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n        s.head[s.ins_h] = s.strstart;\n        /***/\n      }\n\n      /* Find the longest match, discarding those <= prev_length.\n       */\n      s.prev_length = s.match_length;\n      s.prev_match = s.match_start;\n      s.match_length = MIN_MATCH - 1;\n\n      if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&\n          s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {\n        /* To simplify the code, we prevent matches with the string\n         * of window index 0 (in particular we have to avoid a match\n         * of the string with itself at the start of the input file).\n         */\n        s.match_length = longest_match(s, hash_head);\n        /* longest_match() sets match_start */\n\n        if (s.match_length <= 5 &&\n           (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {\n\n          /* If prev_match is also MIN_MATCH, match_start is garbage\n           * but we will ignore the current match anyway.\n           */\n          s.match_length = MIN_MATCH - 1;\n        }\n      }\n      /* If there was a match at the previous step and the current\n       * match is not better, output the previous match:\n       */\n      if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n        max_insert = s.strstart + s.lookahead - MIN_MATCH;\n        /* Do not insert strings in hash table beyond this. */\n\n        //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n        /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                       s.prev_length - MIN_MATCH, bflush);***/\n        bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n        /* Insert in hash table all strings up to the end of the match.\n         * strstart-1 and strstart are already inserted. If there is not\n         * enough lookahead, the last two strings are not inserted in\n         * the hash table.\n         */\n        s.lookahead -= s.prev_length - 1;\n        s.prev_length -= 2;\n        do {\n          if (++s.strstart <= max_insert) {\n            /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n            s.head[s.ins_h] = s.strstart;\n            /***/\n          }\n        } while (--s.prev_length !== 0);\n        s.match_available = 0;\n        s.match_length = MIN_MATCH - 1;\n        s.strstart++;\n\n        if (bflush) {\n          /*** FLUSH_BLOCK(s, 0); ***/\n          flush_block_only(s, false);\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n          /***/\n        }\n\n      } else if (s.match_available) {\n        /* If there was no match at the previous position, output a\n         * single literal. If there was a match but the current match\n         * is longer, truncate the previous match to a single literal.\n         */\n        //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n        /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n        bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);\n\n        if (bflush) {\n          /*** FLUSH_BLOCK_ONLY(s, 0) ***/\n          flush_block_only(s, false);\n          /***/\n        }\n        s.strstart++;\n        s.lookahead--;\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n      } else {\n        /* There is no previous match to compare with, wait for\n         * the next step to decide.\n         */\n        s.match_available = 1;\n        s.strstart++;\n        s.lookahead--;\n      }\n    }\n    //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n    if (s.match_available) {\n      //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);\n\n      s.match_available = 0;\n    }\n    s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n    if (flush === Z_FINISH$1) {\n      /*** FLUSH_BLOCK(s, 1); ***/\n      flush_block_only(s, true);\n      if (s.strm.avail_out === 0) {\n        return BS_FINISH_STARTED;\n      }\n      /***/\n      return BS_FINISH_DONE;\n    }\n    if (s.last_lit) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n\n    return BS_BLOCK_DONE;\n  };\n\n\n  /* ===========================================================================\n   * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n   * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n   * deflate switches away from Z_RLE.)\n   */\n  const deflate_rle = (s, flush) => {\n\n    let bflush;            /* set if current block must be flushed */\n    let prev;              /* byte at distance one to match */\n    let scan, strend;      /* scan goes up to strend for length of run */\n\n    const _win = s.window;\n\n    for (;;) {\n      /* Make sure that we always have enough lookahead, except\n       * at the end of the input file. We need MAX_MATCH bytes\n       * for the longest run, plus one for the unrolled loop.\n       */\n      if (s.lookahead <= MAX_MATCH) {\n        fill_window(s);\n        if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$1) {\n          return BS_NEED_MORE;\n        }\n        if (s.lookahead === 0) { break; } /* flush the current block */\n      }\n\n      /* See how many times the previous byte repeats */\n      s.match_length = 0;\n      if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n        scan = s.strstart - 1;\n        prev = _win[scan];\n        if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n          strend = s.strstart + MAX_MATCH;\n          do {\n            /*jshint noempty:false*/\n          } while (prev === _win[++scan] && prev === _win[++scan] &&\n                   prev === _win[++scan] && prev === _win[++scan] &&\n                   prev === _win[++scan] && prev === _win[++scan] &&\n                   prev === _win[++scan] && prev === _win[++scan] &&\n                   scan < strend);\n          s.match_length = MAX_MATCH - (strend - scan);\n          if (s.match_length > s.lookahead) {\n            s.match_length = s.lookahead;\n          }\n        }\n        //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n      }\n\n      /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n      if (s.match_length >= MIN_MATCH) {\n        //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n        /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n        bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);\n\n        s.lookahead -= s.match_length;\n        s.strstart += s.match_length;\n        s.match_length = 0;\n      } else {\n        /* No match, output a literal byte */\n        //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n        /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n        bflush = _tr_tally(s, 0, s.window[s.strstart]);\n\n        s.lookahead--;\n        s.strstart++;\n      }\n      if (bflush) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n    }\n    s.insert = 0;\n    if (flush === Z_FINISH$1) {\n      /*** FLUSH_BLOCK(s, 1); ***/\n      flush_block_only(s, true);\n      if (s.strm.avail_out === 0) {\n        return BS_FINISH_STARTED;\n      }\n      /***/\n      return BS_FINISH_DONE;\n    }\n    if (s.last_lit) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n    return BS_BLOCK_DONE;\n  };\n\n  /* ===========================================================================\n   * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n   * (It will be regenerated if this run of deflate switches away from Huffman.)\n   */\n  const deflate_huff = (s, flush) => {\n\n    let bflush;             /* set if current block must be flushed */\n\n    for (;;) {\n      /* Make sure that we have a literal to write. */\n      if (s.lookahead === 0) {\n        fill_window(s);\n        if (s.lookahead === 0) {\n          if (flush === Z_NO_FLUSH$1) {\n            return BS_NEED_MORE;\n          }\n          break;      /* flush the current block */\n        }\n      }\n\n      /* Output a literal byte */\n      s.match_length = 0;\n      //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = _tr_tally(s, 0, s.window[s.strstart]);\n      s.lookahead--;\n      s.strstart++;\n      if (bflush) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n    }\n    s.insert = 0;\n    if (flush === Z_FINISH$1) {\n      /*** FLUSH_BLOCK(s, 1); ***/\n      flush_block_only(s, true);\n      if (s.strm.avail_out === 0) {\n        return BS_FINISH_STARTED;\n      }\n      /***/\n      return BS_FINISH_DONE;\n    }\n    if (s.last_lit) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n    return BS_BLOCK_DONE;\n  };\n\n  /* Values for max_lazy_match, good_match and max_chain_length, depending on\n   * the desired pack level (0..9). The values given below have been tuned to\n   * exclude worst case performance for pathological files. Better values may be\n   * found for specific files.\n   */\n  function Config(good_length, max_lazy, nice_length, max_chain, func) {\n\n    this.good_length = good_length;\n    this.max_lazy = max_lazy;\n    this.nice_length = nice_length;\n    this.max_chain = max_chain;\n    this.func = func;\n  }\n\n  const configuration_table = [\n    /*      good lazy nice chain */\n    new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */\n    new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */\n    new Config(4, 5, 16, 8, deflate_fast),           /* 2 */\n    new Config(4, 6, 32, 32, deflate_fast),          /* 3 */\n\n    new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */\n    new Config(8, 16, 32, 32, deflate_slow),         /* 5 */\n    new Config(8, 16, 128, 128, deflate_slow),       /* 6 */\n    new Config(8, 32, 128, 256, deflate_slow),       /* 7 */\n    new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */\n    new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */\n  ];\n\n\n  /* ===========================================================================\n   * Initialize the \"longest match\" routines for a new zlib stream\n   */\n  const lm_init = (s) => {\n\n    s.window_size = 2 * s.w_size;\n\n    /*** CLEAR_HASH(s); ***/\n    zero(s.head); // Fill with NIL (= 0);\n\n    /* Set the default configuration parameters:\n     */\n    s.max_lazy_match = configuration_table[s.level].max_lazy;\n    s.good_match = configuration_table[s.level].good_length;\n    s.nice_match = configuration_table[s.level].nice_length;\n    s.max_chain_length = configuration_table[s.level].max_chain;\n\n    s.strstart = 0;\n    s.block_start = 0;\n    s.lookahead = 0;\n    s.insert = 0;\n    s.match_length = s.prev_length = MIN_MATCH - 1;\n    s.match_available = 0;\n    s.ins_h = 0;\n  };\n\n\n  function DeflateState() {\n    this.strm = null;            /* pointer back to this zlib stream */\n    this.status = 0;            /* as the name implies */\n    this.pending_buf = null;      /* output still pending */\n    this.pending_buf_size = 0;  /* size of pending_buf */\n    this.pending_out = 0;       /* next pending byte to output to the stream */\n    this.pending = 0;           /* nb of bytes in the pending buffer */\n    this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n    this.gzhead = null;         /* gzip header information to write */\n    this.gzindex = 0;           /* where in extra, name, or comment */\n    this.method = Z_DEFLATED$1; /* can only be DEFLATED */\n    this.last_flush = -1;   /* value of flush param for previous deflate call */\n\n    this.w_size = 0;  /* LZ77 window size (32K by default) */\n    this.w_bits = 0;  /* log2(w_size)  (8..16) */\n    this.w_mask = 0;  /* w_size - 1 */\n\n    this.window = null;\n    /* Sliding window. Input bytes are read into the second half of the window,\n     * and move to the first half later to keep a dictionary of at least wSize\n     * bytes. With this organization, matches are limited to a distance of\n     * wSize-MAX_MATCH bytes, but this ensures that IO is always\n     * performed with a length multiple of the block size.\n     */\n\n    this.window_size = 0;\n    /* Actual size of window: 2*wSize, except when the user input buffer\n     * is directly used as sliding window.\n     */\n\n    this.prev = null;\n    /* Link to older string with same hash index. To limit the size of this\n     * array to 64K, this link is maintained only for the last 32K strings.\n     * An index in this array is thus a window index modulo 32K.\n     */\n\n    this.head = null;   /* Heads of the hash chains or NIL. */\n\n    this.ins_h = 0;       /* hash index of string to be inserted */\n    this.hash_size = 0;   /* number of elements in hash table */\n    this.hash_bits = 0;   /* log2(hash_size) */\n    this.hash_mask = 0;   /* hash_size-1 */\n\n    this.hash_shift = 0;\n    /* Number of bits by which ins_h must be shifted at each input\n     * step. It must be such that after MIN_MATCH steps, the oldest\n     * byte no longer takes part in the hash key, that is:\n     *   hash_shift * MIN_MATCH >= hash_bits\n     */\n\n    this.block_start = 0;\n    /* Window position at the beginning of the current output block. Gets\n     * negative when the window is moved backwards.\n     */\n\n    this.match_length = 0;      /* length of best match */\n    this.prev_match = 0;        /* previous match */\n    this.match_available = 0;   /* set if previous match exists */\n    this.strstart = 0;          /* start of string to insert */\n    this.match_start = 0;       /* start of matching string */\n    this.lookahead = 0;         /* number of valid bytes ahead in window */\n\n    this.prev_length = 0;\n    /* Length of the best match at previous step. Matches not greater than this\n     * are discarded. This is used in the lazy match evaluation.\n     */\n\n    this.max_chain_length = 0;\n    /* To speed up deflation, hash chains are never searched beyond this\n     * length.  A higher limit improves compression ratio but degrades the\n     * speed.\n     */\n\n    this.max_lazy_match = 0;\n    /* Attempt to find a better match only when the current match is strictly\n     * smaller than this value. This mechanism is used only for compression\n     * levels >= 4.\n     */\n    // That's alias to max_lazy_match, don't use directly\n    //this.max_insert_length = 0;\n    /* Insert new strings in the hash table only if the match length is not\n     * greater than this length. This saves time but degrades compression.\n     * max_insert_length is used only for compression levels <= 3.\n     */\n\n    this.level = 0;     /* compression level (1..9) */\n    this.strategy = 0;  /* favor or force Huffman coding*/\n\n    this.good_match = 0;\n    /* Use a faster search when the previous match is longer than this */\n\n    this.nice_match = 0; /* Stop searching when current match exceeds this */\n\n                /* used by trees.c: */\n\n    /* Didn't use ct_data typedef below to suppress compiler warning */\n\n    // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n    // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n    // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n    // Use flat array of DOUBLE size, with interleaved fata,\n    // because JS does not support effective\n    this.dyn_ltree  = new Uint16Array(HEAP_SIZE * 2);\n    this.dyn_dtree  = new Uint16Array((2 * D_CODES + 1) * 2);\n    this.bl_tree    = new Uint16Array((2 * BL_CODES + 1) * 2);\n    zero(this.dyn_ltree);\n    zero(this.dyn_dtree);\n    zero(this.bl_tree);\n\n    this.l_desc   = null;         /* desc. for literal tree */\n    this.d_desc   = null;         /* desc. for distance tree */\n    this.bl_desc  = null;         /* desc. for bit length tree */\n\n    //ush bl_count[MAX_BITS+1];\n    this.bl_count = new Uint16Array(MAX_BITS + 1);\n    /* number of codes at each bit length for an optimal tree */\n\n    //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n    this.heap = new Uint16Array(2 * L_CODES + 1);  /* heap used to build the Huffman trees */\n    zero(this.heap);\n\n    this.heap_len = 0;               /* number of elements in the heap */\n    this.heap_max = 0;               /* element of largest frequency */\n    /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n     * The same heap array is used to build all trees.\n     */\n\n    this.depth = new Uint16Array(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n    zero(this.depth);\n    /* Depth of each subtree used as tie breaker for trees of equal frequency\n     */\n\n    this.l_buf = 0;          /* buffer index for literals or lengths */\n\n    this.lit_bufsize = 0;\n    /* Size of match buffer for literals/lengths.  There are 4 reasons for\n     * limiting lit_bufsize to 64K:\n     *   - frequencies can be kept in 16 bit counters\n     *   - if compression is not successful for the first block, all input\n     *     data is still in the window so we can still emit a stored block even\n     *     when input comes from standard input.  (This can also be done for\n     *     all blocks if lit_bufsize is not greater than 32K.)\n     *   - if compression is not successful for a file smaller than 64K, we can\n     *     even emit a stored file instead of a stored block (saving 5 bytes).\n     *     This is applicable only for zip (not gzip or zlib).\n     *   - creating new Huffman trees less frequently may not provide fast\n     *     adaptation to changes in the input data statistics. (Take for\n     *     example a binary file with poorly compressible code followed by\n     *     a highly compressible string table.) Smaller buffer sizes give\n     *     fast adaptation but have of course the overhead of transmitting\n     *     trees more frequently.\n     *   - I can't count above 4\n     */\n\n    this.last_lit = 0;      /* running index in l_buf */\n\n    this.d_buf = 0;\n    /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n     * the same number of elements. To use different lengths, an extra flag\n     * array would be necessary.\n     */\n\n    this.opt_len = 0;       /* bit length of current block with optimal trees */\n    this.static_len = 0;    /* bit length of current block with static trees */\n    this.matches = 0;       /* number of string matches in current block */\n    this.insert = 0;        /* bytes at end of window left to insert */\n\n\n    this.bi_buf = 0;\n    /* Output buffer. bits are inserted starting at the bottom (least\n     * significant bits).\n     */\n    this.bi_valid = 0;\n    /* Number of valid bits in bi_buf.  All bits above the last valid bit\n     * are always zero.\n     */\n\n    // Used for window memory init. We safely ignore it for JS. That makes\n    // sense only for pointers and memory check tools.\n    //this.high_water = 0;\n    /* High water mark offset in window for initialized bytes -- bytes above\n     * this are set to zero in order to avoid memory check warnings when\n     * longest match routines access bytes past the input.  This is then\n     * updated to the new high water mark.\n     */\n  }\n\n\n  const deflateResetKeep = (strm) => {\n\n    if (!strm || !strm.state) {\n      return err(strm, Z_STREAM_ERROR);\n    }\n\n    strm.total_in = strm.total_out = 0;\n    strm.data_type = Z_UNKNOWN;\n\n    const s = strm.state;\n    s.pending = 0;\n    s.pending_out = 0;\n\n    if (s.wrap < 0) {\n      s.wrap = -s.wrap;\n      /* was made negative by deflate(..., Z_FINISH); */\n    }\n    s.status = (s.wrap ? INIT_STATE : BUSY_STATE);\n    strm.adler = (s.wrap === 2) ?\n      0  // crc32(0, Z_NULL, 0)\n    :\n      1; // adler32(0, Z_NULL, 0)\n    s.last_flush = Z_NO_FLUSH$1;\n    _tr_init(s);\n    return Z_OK$1;\n  };\n\n\n  const deflateReset = (strm) => {\n\n    const ret = deflateResetKeep(strm);\n    if (ret === Z_OK$1) {\n      lm_init(strm.state);\n    }\n    return ret;\n  };\n\n\n  const deflateSetHeader = (strm, head) => {\n\n    if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n    if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }\n    strm.state.gzhead = head;\n    return Z_OK$1;\n  };\n\n\n  const deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {\n\n    if (!strm) { // === Z_NULL\n      return Z_STREAM_ERROR;\n    }\n    let wrap = 1;\n\n    if (level === Z_DEFAULT_COMPRESSION$1) {\n      level = 6;\n    }\n\n    if (windowBits < 0) { /* suppress zlib wrapper */\n      wrap = 0;\n      windowBits = -windowBits;\n    }\n\n    else if (windowBits > 15) {\n      wrap = 2;           /* write gzip wrapper instead */\n      windowBits -= 16;\n    }\n\n\n    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$1 ||\n      windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n      strategy < 0 || strategy > Z_FIXED) {\n      return err(strm, Z_STREAM_ERROR);\n    }\n\n\n    if (windowBits === 8) {\n      windowBits = 9;\n    }\n    /* until 256-byte window bug fixed */\n\n    const s = new DeflateState();\n\n    strm.state = s;\n    s.strm = strm;\n\n    s.wrap = wrap;\n    s.gzhead = null;\n    s.w_bits = windowBits;\n    s.w_size = 1 << s.w_bits;\n    s.w_mask = s.w_size - 1;\n\n    s.hash_bits = memLevel + 7;\n    s.hash_size = 1 << s.hash_bits;\n    s.hash_mask = s.hash_size - 1;\n    s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n\n    s.window = new Uint8Array(s.w_size * 2);\n    s.head = new Uint16Array(s.hash_size);\n    s.prev = new Uint16Array(s.w_size);\n\n    // Don't need mem init magic for JS.\n    //s.high_water = 0;  /* nothing written to s->window yet */\n\n    s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n\n    s.pending_buf_size = s.lit_bufsize * 4;\n\n    //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n    //s->pending_buf = (uchf *) overlay;\n    s.pending_buf = new Uint8Array(s.pending_buf_size);\n\n    // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n    //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n    s.d_buf = 1 * s.lit_bufsize;\n\n    //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n    s.l_buf = (1 + 2) * s.lit_bufsize;\n\n    s.level = level;\n    s.strategy = strategy;\n    s.method = method;\n\n    return deflateReset(strm);\n  };\n\n  const deflateInit = (strm, level) => {\n\n    return deflateInit2(strm, level, Z_DEFLATED$1, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);\n  };\n\n\n  const deflate$1 = (strm, flush) => {\n\n    let beg, val; // for gzip header write only\n\n    if (!strm || !strm.state ||\n      flush > Z_BLOCK || flush < 0) {\n      return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n    }\n\n    const s = strm.state;\n\n    if (!strm.output ||\n        (!strm.input && strm.avail_in !== 0) ||\n        (s.status === FINISH_STATE && flush !== Z_FINISH$1)) {\n      return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);\n    }\n\n    s.strm = strm; /* just in case */\n    const old_flush = s.last_flush;\n    s.last_flush = flush;\n\n    /* Write the header */\n    if (s.status === INIT_STATE) {\n\n      if (s.wrap === 2) { // GZIP header\n        strm.adler = 0;  //crc32(0L, Z_NULL, 0);\n        put_byte(s, 31);\n        put_byte(s, 139);\n        put_byte(s, 8);\n        if (!s.gzhead) { // s->gzhead == Z_NULL\n          put_byte(s, 0);\n          put_byte(s, 0);\n          put_byte(s, 0);\n          put_byte(s, 0);\n          put_byte(s, 0);\n          put_byte(s, s.level === 9 ? 2 :\n                      (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                       4 : 0));\n          put_byte(s, OS_CODE);\n          s.status = BUSY_STATE;\n        }\n        else {\n          put_byte(s, (s.gzhead.text ? 1 : 0) +\n                      (s.gzhead.hcrc ? 2 : 0) +\n                      (!s.gzhead.extra ? 0 : 4) +\n                      (!s.gzhead.name ? 0 : 8) +\n                      (!s.gzhead.comment ? 0 : 16)\n          );\n          put_byte(s, s.gzhead.time & 0xff);\n          put_byte(s, (s.gzhead.time >> 8) & 0xff);\n          put_byte(s, (s.gzhead.time >> 16) & 0xff);\n          put_byte(s, (s.gzhead.time >> 24) & 0xff);\n          put_byte(s, s.level === 9 ? 2 :\n                      (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                       4 : 0));\n          put_byte(s, s.gzhead.os & 0xff);\n          if (s.gzhead.extra && s.gzhead.extra.length) {\n            put_byte(s, s.gzhead.extra.length & 0xff);\n            put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\n          }\n          if (s.gzhead.hcrc) {\n            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);\n          }\n          s.gzindex = 0;\n          s.status = EXTRA_STATE;\n        }\n      }\n      else // DEFLATE header\n      {\n        let header = (Z_DEFLATED$1 + ((s.w_bits - 8) << 4)) << 8;\n        let level_flags = -1;\n\n        if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n          level_flags = 0;\n        } else if (s.level < 6) {\n          level_flags = 1;\n        } else if (s.level === 6) {\n          level_flags = 2;\n        } else {\n          level_flags = 3;\n        }\n        header |= (level_flags << 6);\n        if (s.strstart !== 0) { header |= PRESET_DICT; }\n        header += 31 - (header % 31);\n\n        s.status = BUSY_STATE;\n        putShortMSB(s, header);\n\n        /* Save the adler32 of the preset dictionary: */\n        if (s.strstart !== 0) {\n          putShortMSB(s, strm.adler >>> 16);\n          putShortMSB(s, strm.adler & 0xffff);\n        }\n        strm.adler = 1; // adler32(0L, Z_NULL, 0);\n      }\n    }\n\n  //#ifdef GZIP\n    if (s.status === EXTRA_STATE) {\n      if (s.gzhead.extra/* != Z_NULL*/) {\n        beg = s.pending;  /* start of bytes to update crc */\n\n        while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n          if (s.pending === s.pending_buf_size) {\n            if (s.gzhead.hcrc && s.pending > beg) {\n              strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n            }\n            flush_pending(strm);\n            beg = s.pending;\n            if (s.pending === s.pending_buf_size) {\n              break;\n            }\n          }\n          put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n          s.gzindex++;\n        }\n        if (s.gzhead.hcrc && s.pending > beg) {\n          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n        }\n        if (s.gzindex === s.gzhead.extra.length) {\n          s.gzindex = 0;\n          s.status = NAME_STATE;\n        }\n      }\n      else {\n        s.status = NAME_STATE;\n      }\n    }\n    if (s.status === NAME_STATE) {\n      if (s.gzhead.name/* != Z_NULL*/) {\n        beg = s.pending;  /* start of bytes to update crc */\n        //int val;\n\n        do {\n          if (s.pending === s.pending_buf_size) {\n            if (s.gzhead.hcrc && s.pending > beg) {\n              strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n            }\n            flush_pending(strm);\n            beg = s.pending;\n            if (s.pending === s.pending_buf_size) {\n              val = 1;\n              break;\n            }\n          }\n          // JS specific: little magic to add zero terminator to end of string\n          if (s.gzindex < s.gzhead.name.length) {\n            val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n          } else {\n            val = 0;\n          }\n          put_byte(s, val);\n        } while (val !== 0);\n\n        if (s.gzhead.hcrc && s.pending > beg) {\n          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n        }\n        if (val === 0) {\n          s.gzindex = 0;\n          s.status = COMMENT_STATE;\n        }\n      }\n      else {\n        s.status = COMMENT_STATE;\n      }\n    }\n    if (s.status === COMMENT_STATE) {\n      if (s.gzhead.comment/* != Z_NULL*/) {\n        beg = s.pending;  /* start of bytes to update crc */\n        //int val;\n\n        do {\n          if (s.pending === s.pending_buf_size) {\n            if (s.gzhead.hcrc && s.pending > beg) {\n              strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n            }\n            flush_pending(strm);\n            beg = s.pending;\n            if (s.pending === s.pending_buf_size) {\n              val = 1;\n              break;\n            }\n          }\n          // JS specific: little magic to add zero terminator to end of string\n          if (s.gzindex < s.gzhead.comment.length) {\n            val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n          } else {\n            val = 0;\n          }\n          put_byte(s, val);\n        } while (val !== 0);\n\n        if (s.gzhead.hcrc && s.pending > beg) {\n          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n        }\n        if (val === 0) {\n          s.status = HCRC_STATE;\n        }\n      }\n      else {\n        s.status = HCRC_STATE;\n      }\n    }\n    if (s.status === HCRC_STATE) {\n      if (s.gzhead.hcrc) {\n        if (s.pending + 2 > s.pending_buf_size) {\n          flush_pending(strm);\n        }\n        if (s.pending + 2 <= s.pending_buf_size) {\n          put_byte(s, strm.adler & 0xff);\n          put_byte(s, (strm.adler >> 8) & 0xff);\n          strm.adler = 0; //crc32(0L, Z_NULL, 0);\n          s.status = BUSY_STATE;\n        }\n      }\n      else {\n        s.status = BUSY_STATE;\n      }\n    }\n  //#endif\n\n    /* Flush as much pending output as possible */\n    if (s.pending !== 0) {\n      flush_pending(strm);\n      if (strm.avail_out === 0) {\n        /* Since avail_out is 0, deflate will be called again with\n         * more output space, but possibly with both pending and\n         * avail_in equal to zero. There won't be anything to do,\n         * but this is not an error situation so make sure we\n         * return OK instead of BUF_ERROR at next call of deflate:\n         */\n        s.last_flush = -1;\n        return Z_OK$1;\n      }\n\n      /* Make sure there is something to do and avoid duplicate consecutive\n       * flushes. For repeated and useless calls with Z_FINISH, we keep\n       * returning Z_STREAM_END instead of Z_BUF_ERROR.\n       */\n    } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&\n      flush !== Z_FINISH$1) {\n      return err(strm, Z_BUF_ERROR);\n    }\n\n    /* User must not provide more input after the first FINISH: */\n    if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n      return err(strm, Z_BUF_ERROR);\n    }\n\n    /* Start a new block or continue the current one.\n     */\n    if (strm.avail_in !== 0 || s.lookahead !== 0 ||\n      (flush !== Z_NO_FLUSH$1 && s.status !== FINISH_STATE)) {\n      let bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :\n        (s.strategy === Z_RLE ? deflate_rle(s, flush) :\n          configuration_table[s.level].func(s, flush));\n\n      if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n        s.status = FINISH_STATE;\n      }\n      if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n        if (strm.avail_out === 0) {\n          s.last_flush = -1;\n          /* avoid BUF_ERROR next call, see above */\n        }\n        return Z_OK$1;\n        /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n         * of deflate should use the same flush parameter to make sure\n         * that the flush is complete. So we don't have to output an\n         * empty block here, this will be done at next call. This also\n         * ensures that for a very small output buffer, we emit at most\n         * one empty block.\n         */\n      }\n      if (bstate === BS_BLOCK_DONE) {\n        if (flush === Z_PARTIAL_FLUSH) {\n          _tr_align(s);\n        }\n        else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */\n\n          _tr_stored_block(s, 0, 0, false);\n          /* For a full flush, this empty block will be recognized\n           * as a special marker by inflate_sync().\n           */\n          if (flush === Z_FULL_FLUSH$1) {\n            /*** CLEAR_HASH(s); ***/             /* forget history */\n            zero(s.head); // Fill with NIL (= 0);\n\n            if (s.lookahead === 0) {\n              s.strstart = 0;\n              s.block_start = 0;\n              s.insert = 0;\n            }\n          }\n        }\n        flush_pending(strm);\n        if (strm.avail_out === 0) {\n          s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n          return Z_OK$1;\n        }\n      }\n    }\n    //Assert(strm->avail_out > 0, \"bug2\");\n    //if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n\n    if (flush !== Z_FINISH$1) { return Z_OK$1; }\n    if (s.wrap <= 0) { return Z_STREAM_END$1; }\n\n    /* Write the trailer */\n    if (s.wrap === 2) {\n      put_byte(s, strm.adler & 0xff);\n      put_byte(s, (strm.adler >> 8) & 0xff);\n      put_byte(s, (strm.adler >> 16) & 0xff);\n      put_byte(s, (strm.adler >> 24) & 0xff);\n      put_byte(s, strm.total_in & 0xff);\n      put_byte(s, (strm.total_in >> 8) & 0xff);\n      put_byte(s, (strm.total_in >> 16) & 0xff);\n      put_byte(s, (strm.total_in >> 24) & 0xff);\n    }\n    else\n    {\n      putShortMSB(s, strm.adler >>> 16);\n      putShortMSB(s, strm.adler & 0xffff);\n    }\n\n    flush_pending(strm);\n    /* If avail_out is zero, the application will call deflate again\n     * to flush the rest.\n     */\n    if (s.wrap > 0) { s.wrap = -s.wrap; }\n    /* write the trailer only once! */\n    return s.pending !== 0 ? Z_OK$1 : Z_STREAM_END$1;\n  };\n\n\n  const deflateEnd = (strm) => {\n\n    if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n      return Z_STREAM_ERROR;\n    }\n\n    const status = strm.state.status;\n    if (status !== INIT_STATE &&\n      status !== EXTRA_STATE &&\n      status !== NAME_STATE &&\n      status !== COMMENT_STATE &&\n      status !== HCRC_STATE &&\n      status !== BUSY_STATE &&\n      status !== FINISH_STATE\n    ) {\n      return err(strm, Z_STREAM_ERROR);\n    }\n\n    strm.state = null;\n\n    return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK$1;\n  };\n\n\n  /* =========================================================================\n   * Initializes the compression dictionary from the given byte\n   * sequence without producing any compressed output.\n   */\n  const deflateSetDictionary = (strm, dictionary) => {\n\n    let dictLength = dictionary.length;\n\n    if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n      return Z_STREAM_ERROR;\n    }\n\n    const s = strm.state;\n    const wrap = s.wrap;\n\n    if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n      return Z_STREAM_ERROR;\n    }\n\n    /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n    if (wrap === 1) {\n      /* adler32(strm->adler, dictionary, dictLength); */\n      strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);\n    }\n\n    s.wrap = 0;   /* avoid computing Adler-32 in read_buf */\n\n    /* if dictionary would fill window, just replace the history */\n    if (dictLength >= s.w_size) {\n      if (wrap === 0) {            /* already empty otherwise */\n        /*** CLEAR_HASH(s); ***/\n        zero(s.head); // Fill with NIL (= 0);\n        s.strstart = 0;\n        s.block_start = 0;\n        s.insert = 0;\n      }\n      /* use the tail */\n      // dictionary = dictionary.slice(dictLength - s.w_size);\n      let tmpDict = new Uint8Array(s.w_size);\n      tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);\n      dictionary = tmpDict;\n      dictLength = s.w_size;\n    }\n    /* insert dictionary into window and hash */\n    const avail = strm.avail_in;\n    const next = strm.next_in;\n    const input = strm.input;\n    strm.avail_in = dictLength;\n    strm.next_in = 0;\n    strm.input = dictionary;\n    fill_window(s);\n    while (s.lookahead >= MIN_MATCH) {\n      let str = s.strstart;\n      let n = s.lookahead - (MIN_MATCH - 1);\n      do {\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);\n\n        s.prev[str & s.w_mask] = s.head[s.ins_h];\n\n        s.head[s.ins_h] = str;\n        str++;\n      } while (--n);\n      s.strstart = str;\n      s.lookahead = MIN_MATCH - 1;\n      fill_window(s);\n    }\n    s.strstart += s.lookahead;\n    s.block_start = s.strstart;\n    s.insert = s.lookahead;\n    s.lookahead = 0;\n    s.match_length = s.prev_length = MIN_MATCH - 1;\n    s.match_available = 0;\n    strm.next_in = next;\n    strm.input = input;\n    strm.avail_in = avail;\n    s.wrap = wrap;\n    return Z_OK$1;\n  };\n\n\n  var deflateInit_1 = deflateInit;\n  var deflateInit2_1 = deflateInit2;\n  var deflateReset_1 = deflateReset;\n  var deflateResetKeep_1 = deflateResetKeep;\n  var deflateSetHeader_1 = deflateSetHeader;\n  var deflate_2$1 = deflate$1;\n  var deflateEnd_1 = deflateEnd;\n  var deflateSetDictionary_1 = deflateSetDictionary;\n  var deflateInfo = 'pako deflate (from Nodeca project)';\n\n  /* Not implemented\n  module.exports.deflateBound = deflateBound;\n  module.exports.deflateCopy = deflateCopy;\n  module.exports.deflateParams = deflateParams;\n  module.exports.deflatePending = deflatePending;\n  module.exports.deflatePrime = deflatePrime;\n  module.exports.deflateTune = deflateTune;\n  */\n\n  var deflate_1$1 = {\n  \tdeflateInit: deflateInit_1,\n  \tdeflateInit2: deflateInit2_1,\n  \tdeflateReset: deflateReset_1,\n  \tdeflateResetKeep: deflateResetKeep_1,\n  \tdeflateSetHeader: deflateSetHeader_1,\n  \tdeflate: deflate_2$1,\n  \tdeflateEnd: deflateEnd_1,\n  \tdeflateSetDictionary: deflateSetDictionary_1,\n  \tdeflateInfo: deflateInfo\n  };\n\n  const _has = (obj, key) => {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n  };\n\n  var assign = function (obj /*from1, from2, from3, ...*/) {\n    const sources = Array.prototype.slice.call(arguments, 1);\n    while (sources.length) {\n      const source = sources.shift();\n      if (!source) { continue; }\n\n      if (typeof source !== 'object') {\n        throw new TypeError(source + 'must be non-object');\n      }\n\n      for (const p in source) {\n        if (_has(source, p)) {\n          obj[p] = source[p];\n        }\n      }\n    }\n\n    return obj;\n  };\n\n\n  // Join array of chunks to single array.\n  var flattenChunks = (chunks) => {\n    // calculate data length\n    let len = 0;\n\n    for (let i = 0, l = chunks.length; i < l; i++) {\n      len += chunks[i].length;\n    }\n\n    // join chunks\n    const result = new Uint8Array(len);\n\n    for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {\n      let chunk = chunks[i];\n      result.set(chunk, pos);\n      pos += chunk.length;\n    }\n\n    return result;\n  };\n\n  var common = {\n  \tassign: assign,\n  \tflattenChunks: flattenChunks\n  };\n\n  // String encode/decode helpers\n\n\n  // Quick check if we can use fast array to bin string conversion\n  //\n  // - apply(Array) can fail on Android 2.2\n  // - apply(Uint8Array) can fail on iOS 5.1 Safari\n  //\n  let STR_APPLY_UIA_OK = true;\n\n  try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }\n\n\n  // Table with utf8 lengths (calculated by first byte of sequence)\n  // Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n  // because max possible codepoint is 0x10ffff\n  const _utf8len = new Uint8Array(256);\n  for (let q = 0; q < 256; q++) {\n    _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);\n  }\n  _utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n\n\n  // convert string to array (typed, when possible)\n  var string2buf = (str) => {\n    if (typeof TextEncoder === 'function' && TextEncoder.prototype.encode) {\n      return new TextEncoder().encode(str);\n    }\n\n    let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\n    // count binary size\n    for (m_pos = 0; m_pos < str_len; m_pos++) {\n      c = str.charCodeAt(m_pos);\n      if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n        c2 = str.charCodeAt(m_pos + 1);\n        if ((c2 & 0xfc00) === 0xdc00) {\n          c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n          m_pos++;\n        }\n      }\n      buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n    }\n\n    // allocate buffer\n    buf = new Uint8Array(buf_len);\n\n    // convert\n    for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n      c = str.charCodeAt(m_pos);\n      if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n        c2 = str.charCodeAt(m_pos + 1);\n        if ((c2 & 0xfc00) === 0xdc00) {\n          c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n          m_pos++;\n        }\n      }\n      if (c < 0x80) {\n        /* one byte */\n        buf[i++] = c;\n      } else if (c < 0x800) {\n        /* two bytes */\n        buf[i++] = 0xC0 | (c >>> 6);\n        buf[i++] = 0x80 | (c & 0x3f);\n      } else if (c < 0x10000) {\n        /* three bytes */\n        buf[i++] = 0xE0 | (c >>> 12);\n        buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n        buf[i++] = 0x80 | (c & 0x3f);\n      } else {\n        /* four bytes */\n        buf[i++] = 0xf0 | (c >>> 18);\n        buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n        buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n        buf[i++] = 0x80 | (c & 0x3f);\n      }\n    }\n\n    return buf;\n  };\n\n  // Helper\n  const buf2binstring = (buf, len) => {\n    // On Chrome, the arguments in a function call that are allowed is `65534`.\n    // If the length of the buffer is smaller than that, we can use this optimization,\n    // otherwise we will take a slower path.\n    if (len < 65534) {\n      if (buf.subarray && STR_APPLY_UIA_OK) {\n        return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));\n      }\n    }\n\n    let result = '';\n    for (let i = 0; i < len; i++) {\n      result += String.fromCharCode(buf[i]);\n    }\n    return result;\n  };\n\n\n  // convert array to string\n  var buf2string = (buf, max) => {\n    const len = max || buf.length;\n\n    if (typeof TextDecoder === 'function' && TextDecoder.prototype.decode) {\n      return new TextDecoder().decode(buf.subarray(0, max));\n    }\n\n    let i, out;\n\n    // Reserve max possible length (2 words per char)\n    // NB: by unknown reasons, Array is significantly faster for\n    //     String.fromCharCode.apply than Uint16Array.\n    const utf16buf = new Array(len * 2);\n\n    for (out = 0, i = 0; i < len;) {\n      let c = buf[i++];\n      // quick process ascii\n      if (c < 0x80) { utf16buf[out++] = c; continue; }\n\n      let c_len = _utf8len[c];\n      // skip 5 & 6 byte codes\n      if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }\n\n      // apply mask on first byte\n      c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n      // join the rest\n      while (c_len > 1 && i < len) {\n        c = (c << 6) | (buf[i++] & 0x3f);\n        c_len--;\n      }\n\n      // terminated by end of string?\n      if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n\n      if (c < 0x10000) {\n        utf16buf[out++] = c;\n      } else {\n        c -= 0x10000;\n        utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n        utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n      }\n    }\n\n    return buf2binstring(utf16buf, out);\n  };\n\n\n  // Calculate max possible position in utf8 buffer,\n  // that will not break sequence. If that's not possible\n  // - (very small limits) return max size as is.\n  //\n  // buf[] - utf8 bytes array\n  // max   - length limit (mandatory);\n  var utf8border = (buf, max) => {\n\n    max = max || buf.length;\n    if (max > buf.length) { max = buf.length; }\n\n    // go back from last position, until start of sequence found\n    let pos = max - 1;\n    while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n\n    // Very small and broken sequence,\n    // return max, because we should return something anyway.\n    if (pos < 0) { return max; }\n\n    // If we came to start of buffer - that means buffer is too small,\n    // return max too.\n    if (pos === 0) { return max; }\n\n    return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n  };\n\n  var strings = {\n  \tstring2buf: string2buf,\n  \tbuf2string: buf2string,\n  \tutf8border: utf8border\n  };\n\n  // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n  //\n  // This software is provided 'as-is', without any express or implied\n  // warranty. In no event will the authors be held liable for any damages\n  // arising from the use of this software.\n  //\n  // Permission is granted to anyone to use this software for any purpose,\n  // including commercial applications, and to alter it and redistribute it\n  // freely, subject to the following restrictions:\n  //\n  // 1. The origin of this software must not be misrepresented; you must not\n  //   claim that you wrote the original software. If you use this software\n  //   in a product, an acknowledgment in the product documentation would be\n  //   appreciated but is not required.\n  // 2. Altered source versions must be plainly marked as such, and must not be\n  //   misrepresented as being the original software.\n  // 3. This notice may not be removed or altered from any source distribution.\n\n  function ZStream() {\n    /* next input byte */\n    this.input = null; // JS specific, because we have no pointers\n    this.next_in = 0;\n    /* number of bytes available at input */\n    this.avail_in = 0;\n    /* total number of input bytes read so far */\n    this.total_in = 0;\n    /* next output byte should be put there */\n    this.output = null; // JS specific, because we have no pointers\n    this.next_out = 0;\n    /* remaining free space at output */\n    this.avail_out = 0;\n    /* total number of bytes output so far */\n    this.total_out = 0;\n    /* last error message, NULL if no error */\n    this.msg = ''/*Z_NULL*/;\n    /* not visible by applications */\n    this.state = null;\n    /* best guess about the data type: binary or text */\n    this.data_type = 2/*Z_UNKNOWN*/;\n    /* adler32 value of the uncompressed data */\n    this.adler = 0;\n  }\n\n  var zstream = ZStream;\n\n  const toString = Object.prototype.toString;\n\n  /* Public constants ==========================================================*/\n  /* ===========================================================================*/\n\n  const {\n    Z_NO_FLUSH, Z_SYNC_FLUSH, Z_FULL_FLUSH, Z_FINISH,\n    Z_OK, Z_STREAM_END,\n    Z_DEFAULT_COMPRESSION,\n    Z_DEFAULT_STRATEGY,\n    Z_DEFLATED\n  } = constants$1;\n\n  /* ===========================================================================*/\n\n\n  /**\n   * class Deflate\n   *\n   * Generic JS-style wrapper for zlib calls. If you don't need\n   * streaming behaviour - use more simple functions: [[deflate]],\n   * [[deflateRaw]] and [[gzip]].\n   **/\n\n  /* internal\n   * Deflate.chunks -> Array\n   *\n   * Chunks of output data, if [[Deflate#onData]] not overridden.\n   **/\n\n  /**\n   * Deflate.result -> Uint8Array\n   *\n   * Compressed result, generated by default [[Deflate#onData]]\n   * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n   * (call [[Deflate#push]] with `Z_FINISH` / `true` param).\n   **/\n\n  /**\n   * Deflate.err -> Number\n   *\n   * Error code after deflate finished. 0 (Z_OK) on success.\n   * You will not need it in real life, because deflate errors\n   * are possible only on wrong options or bad `onData` / `onEnd`\n   * custom handlers.\n   **/\n\n  /**\n   * Deflate.msg -> String\n   *\n   * Error message, if [[Deflate.err]] != 0\n   **/\n\n\n  /**\n   * new Deflate(options)\n   * - options (Object): zlib deflate options.\n   *\n   * Creates new deflator instance with specified params. Throws exception\n   * on bad params. Supported options:\n   *\n   * - `level`\n   * - `windowBits`\n   * - `memLevel`\n   * - `strategy`\n   * - `dictionary`\n   *\n   * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n   * for more information on these.\n   *\n   * Additional options, for internal needs:\n   *\n   * - `chunkSize` - size of generated data chunks (16K by default)\n   * - `raw` (Boolean) - do raw deflate\n   * - `gzip` (Boolean) - create gzip wrapper\n   * - `header` (Object) - custom header for gzip\n   *   - `text` (Boolean) - true if compressed data believed to be text\n   *   - `time` (Number) - modification time, unix timestamp\n   *   - `os` (Number) - operation system code\n   *   - `extra` (Array) - array of bytes with extra data (max 65536)\n   *   - `name` (String) - file name (binary string)\n   *   - `comment` (String) - comment (binary string)\n   *   - `hcrc` (Boolean) - true if header crc should be added\n   *\n   * ##### Example:\n   *\n   * ```javascript\n   * const pako = require('pako')\n   *   , chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])\n   *   , chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n   *\n   * const deflate = new pako.Deflate({ level: 3});\n   *\n   * deflate.push(chunk1, false);\n   * deflate.push(chunk2, true);  // true -> last chunk\n   *\n   * if (deflate.err) { throw new Error(deflate.err); }\n   *\n   * console.log(deflate.result);\n   * ```\n   **/\n  function Deflate(options) {\n    this.options = common.assign({\n      level: Z_DEFAULT_COMPRESSION,\n      method: Z_DEFLATED,\n      chunkSize: 16384,\n      windowBits: 15,\n      memLevel: 8,\n      strategy: Z_DEFAULT_STRATEGY\n    }, options || {});\n\n    let opt = this.options;\n\n    if (opt.raw && (opt.windowBits > 0)) {\n      opt.windowBits = -opt.windowBits;\n    }\n\n    else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {\n      opt.windowBits += 16;\n    }\n\n    this.err    = 0;      // error code, if happens (0 = Z_OK)\n    this.msg    = '';     // error message\n    this.ended  = false;  // used to avoid multiple onEnd() calls\n    this.chunks = [];     // chunks of compressed data\n\n    this.strm = new zstream();\n    this.strm.avail_out = 0;\n\n    let status = deflate_1$1.deflateInit2(\n      this.strm,\n      opt.level,\n      opt.method,\n      opt.windowBits,\n      opt.memLevel,\n      opt.strategy\n    );\n\n    if (status !== Z_OK) {\n      throw new Error(messages[status]);\n    }\n\n    if (opt.header) {\n      deflate_1$1.deflateSetHeader(this.strm, opt.header);\n    }\n\n    if (opt.dictionary) {\n      let dict;\n      // Convert data if needed\n      if (typeof opt.dictionary === 'string') {\n        // If we need to compress text, change encoding to utf8.\n        dict = strings.string2buf(opt.dictionary);\n      } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n        dict = new Uint8Array(opt.dictionary);\n      } else {\n        dict = opt.dictionary;\n      }\n\n      status = deflate_1$1.deflateSetDictionary(this.strm, dict);\n\n      if (status !== Z_OK) {\n        throw new Error(messages[status]);\n      }\n\n      this._dict_set = true;\n    }\n  }\n\n  /**\n   * Deflate#push(data[, flush_mode]) -> Boolean\n   * - data (Uint8Array|ArrayBuffer|String): input data. Strings will be\n   *   converted to utf8 byte sequence.\n   * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n   *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n   *\n   * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n   * new compressed chunks. Returns `true` on success. The last data block must\n   * have `flush_mode` Z_FINISH (or `true`). That will flush internal pending\n   * buffers and call [[Deflate#onEnd]].\n   *\n   * On fail call [[Deflate#onEnd]] with error code and return false.\n   *\n   * ##### Example\n   *\n   * ```javascript\n   * push(chunk, false); // push one of data chunks\n   * ...\n   * push(chunk, true);  // push last chunk\n   * ```\n   **/\n  Deflate.prototype.push = function (data, flush_mode) {\n    const strm = this.strm;\n    const chunkSize = this.options.chunkSize;\n    let status, _flush_mode;\n\n    if (this.ended) { return false; }\n\n    if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;\n    else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;\n\n    // Convert data if needed\n    if (typeof data === 'string') {\n      // If we need to compress text, change encoding to utf8.\n      strm.input = strings.string2buf(data);\n    } else if (toString.call(data) === '[object ArrayBuffer]') {\n      strm.input = new Uint8Array(data);\n    } else {\n      strm.input = data;\n    }\n\n    strm.next_in = 0;\n    strm.avail_in = strm.input.length;\n\n    for (;;) {\n      if (strm.avail_out === 0) {\n        strm.output = new Uint8Array(chunkSize);\n        strm.next_out = 0;\n        strm.avail_out = chunkSize;\n      }\n\n      // Make sure avail_out > 6 to avoid repeating markers\n      if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {\n        this.onData(strm.output.subarray(0, strm.next_out));\n        strm.avail_out = 0;\n        continue;\n      }\n\n      status = deflate_1$1.deflate(strm, _flush_mode);\n\n      // Ended => flush and finish\n      if (status === Z_STREAM_END) {\n        if (strm.next_out > 0) {\n          this.onData(strm.output.subarray(0, strm.next_out));\n        }\n        status = deflate_1$1.deflateEnd(this.strm);\n        this.onEnd(status);\n        this.ended = true;\n        return status === Z_OK;\n      }\n\n      // Flush if out buffer full\n      if (strm.avail_out === 0) {\n        this.onData(strm.output);\n        continue;\n      }\n\n      // Flush if requested and has data\n      if (_flush_mode > 0 && strm.next_out > 0) {\n        this.onData(strm.output.subarray(0, strm.next_out));\n        strm.avail_out = 0;\n        continue;\n      }\n\n      if (strm.avail_in === 0) break;\n    }\n\n    return true;\n  };\n\n\n  /**\n   * Deflate#onData(chunk) -> Void\n   * - chunk (Uint8Array): output data.\n   *\n   * By default, stores data blocks in `chunks[]` property and glue\n   * those in `onEnd`. Override this handler, if you need another behaviour.\n   **/\n  Deflate.prototype.onData = function (chunk) {\n    this.chunks.push(chunk);\n  };\n\n\n  /**\n   * Deflate#onEnd(status) -> Void\n   * - status (Number): deflate status. 0 (Z_OK) on success,\n   *   other if not.\n   *\n   * Called once after you tell deflate that the input stream is\n   * complete (Z_FINISH). By default - join collected chunks,\n   * free memory and fill `results` / `err` properties.\n   **/\n  Deflate.prototype.onEnd = function (status) {\n    // On success - join\n    if (status === Z_OK) {\n      this.result = common.flattenChunks(this.chunks);\n    }\n    this.chunks = [];\n    this.err = status;\n    this.msg = this.strm.msg;\n  };\n\n\n  /**\n   * deflate(data[, options]) -> Uint8Array\n   * - data (Uint8Array|String): input data to compress.\n   * - options (Object): zlib deflate options.\n   *\n   * Compress `data` with deflate algorithm and `options`.\n   *\n   * Supported options are:\n   *\n   * - level\n   * - windowBits\n   * - memLevel\n   * - strategy\n   * - dictionary\n   *\n   * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n   * for more information on these.\n   *\n   * Sugar (options):\n   *\n   * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n   *   negative windowBits implicitly.\n   *\n   * ##### Example:\n   *\n   * ```javascript\n   * const pako = require('pako')\n   * const data = new Uint8Array([1,2,3,4,5,6,7,8,9]);\n   *\n   * console.log(pako.deflate(data));\n   * ```\n   **/\n  function deflate(input, options) {\n    const deflator = new Deflate(options);\n\n    deflator.push(input, true);\n\n    // That will never happens, if you don't cheat with options :)\n    if (deflator.err) { throw deflator.msg || messages[deflator.err]; }\n\n    return deflator.result;\n  }\n\n\n  /**\n   * deflateRaw(data[, options]) -> Uint8Array\n   * - data (Uint8Array|String): input data to compress.\n   * - options (Object): zlib deflate options.\n   *\n   * The same as [[deflate]], but creates raw data, without wrapper\n   * (header and adler32 crc).\n   **/\n  function deflateRaw(input, options) {\n    options = options || {};\n    options.raw = true;\n    return deflate(input, options);\n  }\n\n\n  /**\n   * gzip(data[, options]) -> Uint8Array\n   * - data (Uint8Array|String): input data to compress.\n   * - options (Object): zlib deflate options.\n   *\n   * The same as [[deflate]], but create gzip wrapper instead of\n   * deflate one.\n   **/\n  function gzip(input, options) {\n    options = options || {};\n    options.gzip = true;\n    return deflate(input, options);\n  }\n\n\n  var Deflate_1 = Deflate;\n  var deflate_2 = deflate;\n  var deflateRaw_1 = deflateRaw;\n  var gzip_1 = gzip;\n  var constants = constants$1;\n\n  var deflate_1 = {\n  \tDeflate: Deflate_1,\n  \tdeflate: deflate_2,\n  \tdeflateRaw: deflateRaw_1,\n  \tgzip: gzip_1,\n  \tconstants: constants\n  };\n\n  exports.Deflate = Deflate_1;\n  exports.constants = constants;\n  exports['default'] = deflate_1;\n  exports.deflate = deflate_2;\n  exports.deflateRaw = deflateRaw_1;\n  exports.gzip = gzip_1;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n","import { gzip } from 'pako/dist/pako_deflate.js';\n\nself.onmessage = (event) => {\n  try {\n    const result = gzip(event.data.data).buffer;\n    self.postMessage({\n      id: event.data.id,\n      result,\n    });\n  } catch (error) {\n    self.postMessage({\n      id: event.data.id,\n      error: error.message,\n    });\n  }\n};\n"],"names":["exports","Z_FIXED$1","Z_BINARY","Z_TEXT","Z_UNKNOWN$1","zero$1","buf","len","length","STORED_BLOCK","STATIC_TREES","DYN_TREES","MIN_MATCH$1","MAX_MATCH$1","LENGTH_CODES$1","LITERALS$1","L_CODES$1","D_CODES$1","BL_CODES$1","HEAP_SIZE$1","MAX_BITS$1","Buf_size","MAX_BL_BITS","END_BLOCK","REP_3_6","REPZ_3_10","REPZ_11_138","extra_lbits","Uint8Array","extra_dbits","extra_blbits","bl_order","DIST_CODE_LEN","static_ltree","Array","static_dtree","_dist_code","_length_code","base_length","base_dist","StaticTreeDesc","static_tree","extra_bits","extra_base","elems","max_length","this","has_stree","static_l_desc","static_d_desc","static_bl_desc","TreeDesc","dyn_tree","stat_desc","max_code","d_code","dist","put_short","s","w","pending_buf","pending","send_bits","value","bi_valid","bi_buf","send_code","c","tree","bi_reverse","code","res","bi_flush","gen_bitlen","desc","stree","extra","base","h","n","m","bits","xbits","f","overflow","bl_count","heap","heap_max","opt_len","static_len","gen_codes","next_code","tr_static_init","init_block","dyn_ltree","dyn_dtree","bl_tree","last_lit","matches","bi_windup","copy_block","header","set","window","subarray","smaller","depth","_n2","_m2","pqdownheap","k","v","j","heap_len","compress_block","ltree","dtree","lc","lx","d_buf","l_buf","build_tree","node","scan_tree","curlen","prevlen","nextlen","count","max_count","min_count","send_tree","build_bl_tree","max_blindex","l_desc","d_desc","bl_desc","send_all_trees","lcodes","dcodes","blcodes","rank","detect_data_type","black_mask","static_init_done","_tr_stored_block$1","stored_len","last","_tr_flush_block$1","opt_lenb","static_lenb","level","strm","data_type","strategy","trees","_tr_init","_tr_stored_block","_tr_flush_block","_tr_tally","lit_bufsize","_tr_align","adler32_1","adler","pos","s1","s2","crcTable","Uint32Array","table","makeTable","crc32_1","crc","t","end","i","messages","constants$1","Z_NO_FLUSH","Z_PARTIAL_FLUSH","Z_SYNC_FLUSH","Z_FULL_FLUSH","Z_FINISH","Z_BLOCK","Z_TREES","Z_OK","Z_STREAM_END","Z_NEED_DICT","Z_ERRNO","Z_STREAM_ERROR","Z_DATA_ERROR","Z_MEM_ERROR","Z_BUF_ERROR","Z_NO_COMPRESSION","Z_BEST_SPEED","Z_BEST_COMPRESSION","Z_DEFAULT_COMPRESSION","Z_FILTERED","Z_HUFFMAN_ONLY","Z_RLE","Z_FIXED","Z_DEFAULT_STRATEGY","Z_UNKNOWN","Z_DEFLATED","Z_NO_FLUSH$1","Z_FULL_FLUSH$1","Z_FINISH$1","Z_OK$1","Z_STREAM_END$1","Z_DEFAULT_COMPRESSION$1","Z_DEFAULT_STRATEGY$1","Z_DEFLATED$1","MAX_MEM_LEVEL","MAX_WBITS","DEF_MEM_LEVEL","L_CODES","LITERALS","D_CODES","BL_CODES","HEAP_SIZE","MAX_BITS","MIN_MATCH","MAX_MATCH","MIN_LOOKAHEAD","PRESET_DICT","INIT_STATE","EXTRA_STATE","NAME_STATE","COMMENT_STATE","HCRC_STATE","BUSY_STATE","FINISH_STATE","BS_NEED_MORE","BS_BLOCK_DONE","BS_FINISH_STARTED","BS_FINISH_DONE","OS_CODE","err","errorCode","msg","zero","HASH","prev","data","hash_shift","hash_mask","flush_pending","state","avail_out","output","pending_out","next_out","total_out","flush_block_only","block_start","strstart","put_byte","b","putShortMSB","read_buf","start","size","avail_in","input","next_in","wrap","total_in","longest_match","cur_match","match","chain_length","max_chain_length","scan","best_len","prev_length","nice_match","limit","w_size","_win","wmask","w_mask","strend","scan_end1","scan_end","good_match","lookahead","match_start","fill_window","_w_size","p","more","str","window_size","hash_size","head","insert","ins_h","deflate_fast","flush","hash_head","bflush","match_length","max_lazy_match","deflate_slow","max_insert","prev_match","match_available","deflate_rle","deflate_huff","Config","good_length","max_lazy","nice_length","max_chain","func","configuration_table","max_block_size","pending_buf_size","max_start","lm_init","DeflateState","status","gzhead","gzindex","method","last_flush","w_bits","hash_bits","Uint16Array","deflateResetKeep","deflateReset","ret","deflateInit2","windowBits","memLevel","deflate_1$1","deflateInit","deflateSetHeader","deflate","beg","val","old_flush","text","hcrc","name","comment","time","os","level_flags","charCodeAt","bstate","deflateEnd","deflateSetDictionary","dictionary","dictLength","tmpDict","avail","next","deflateInfo","_has","obj","key","Object","prototype","hasOwnProperty","call","assign","sources","slice","arguments","source","shift","TypeError","common","flattenChunks","chunks","l","result","chunk","STR_APPLY_UIA_OK","String","fromCharCode","apply","__","_utf8len","q","buf2binstring","strings","string2buf","TextEncoder","encode","c2","m_pos","str_len","buf_len","buf2string","max","TextDecoder","decode","out","utf16buf","c_len","utf8border","ZStream","zstream","toString","Deflate","options","chunkSize","opt","raw","gzip","ended","Error","dict","_dict_set","deflator","push","deflateRaw","flush_mode","_flush_mode","onData","onEnd","Deflate_1","deflate_2","deflateRaw_1","gzip_1","constants","deflate_1","defineProperty","factory","self","onmessage","event","buffer","postMessage","id","error","message"],"mappings":"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"}